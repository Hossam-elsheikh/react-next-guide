<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React.js & Next.js App Router - Complete Guide</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Georgia", serif;
        line-height: 1.8;
        color: #2c3e50;
        background: #f8f9fa;
      }

      .container {
        max-width: 900px;
        margin: 0 auto;
        background: white;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
      }

      .page {
        padding: 60px 80px;
        min-height: 100vh;
        page-break-after: always;
      }

      .cover {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .cover h1 {
        font-size: 3.5em;
        margin-bottom: 20px;
        font-weight: 700;
      }

      .cover h2 {
        font-size: 2em;
        font-weight: 300;
        margin-bottom: 40px;
      }

      .cover .subtitle {
        font-size: 1.2em;
        opacity: 0.9;
      }

      h1 {
        color: #667eea;
        font-size: 2.5em;
        margin-bottom: 30px;
        border-bottom: 4px solid #667eea;
        padding-bottom: 15px;
      }

      h2 {
        color: #764ba2;
        font-size: 2em;
        margin-top: 40px;
        margin-bottom: 20px;
      }

      h3 {
        color: #555;
        font-size: 1.5em;
        margin-top: 30px;
        margin-bottom: 15px;
      }

      h4 {
        color: #666;
        font-size: 1.2em;
        margin-top: 25px;
        margin-bottom: 10px;
      }

      p {
        margin-bottom: 15px;
        text-align: justify;
      }

      code {
        background: #f4f4f4;
        padding: 2px 6px;
        border-radius: 3px;
        font-family: "Courier New", monospace;
        font-size: 0.9em;
        color: #e83e8c;
      }

      pre {
        background: #282c34;
        color: #abb2bf;
        padding: 20px;
        border-radius: 8px;
        overflow-x: auto;
        margin: 20px 0;
        font-family: "Courier New", monospace;
        font-size: 0.85em;
        line-height: 1.6;
      }

      .example {
        background: #e8f4f8;
        border-left: 4px solid #667eea;
        padding: 20px;
        margin: 20px 0;
        border-radius: 4px;
      }

      .question {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 15px;
        margin: 15px 0;
        border-radius: 4px;
      }

      .answer {
        background: #d4edda;
        border-left: 4px solid #28a745;
        padding: 15px;
        margin: 15px 0 30px 0;
        border-radius: 4px;
      }

      .key-point {
        background: #f8d7da;
        border-left: 4px solid #dc3545;
        padding: 15px;
        margin: 15px 0;
        border-radius: 4px;
      }

      ul,
      ol {
        margin: 15px 0 15px 30px;
      }

      li {
        margin-bottom: 10px;
      }

      .toc {
        background: #f8f9fa;
        padding: 30px;
        border-radius: 8px;
        margin: 30px 0;
      }

      .toc h2 {
        margin-top: 0;
      }

      .toc ul {
        list-style: none;
        margin-left: 0;
      }

      .toc li {
        padding: 8px 0;
        border-bottom: 1px solid #dee2e6;
      }

      .export-btn {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #667eea;
        color: white;
        padding: 12px 24px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        transition: all 0.3s;
        z-index: 1000;
      }

      .export-btn:hover {
        background: #5568d3;
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(102, 126, 234, 0.5);
      }

      @media print {
        .export-btn {
          display: none;
        }
        .page {
          page-break-after: always;
        }
        body {
          background: white;
        }
      }
    </style>
  </head>
  <body>
    <button class="export-btn" onclick="window.print()">
      üìÑ Export to PDF
    </button>

    <div class="container">
      <!-- Cover Page -->
      <div class="page cover">
        <h1 style="color: white">React.js & Next.js</h1>
        <p class="subtitle">
          Comprehensive Guide with Examples & Interview Questions
        </p>
      </div>

      <!-- Table of Contents -->
      <div class="page">
        <div class="toc">
          <h2>Table of Contents</h2>
          <ul>
            <li><strong>Part 1: React.js Deep Dive</strong></li>
            <li style="margin-left: 20px">
              <a href="#react-intro">1. Introduction to React</a>
            </li>
            <li style="margin-left: 20px">
              <a href="#react-core-concepts">2. Core Concepts</a>
            </li>
            <li style="margin-left: 20px">
              <a href="#react-hooks">3. Hooks in Detail</a>
            </li>
            <li style="margin-left: 20px">
              <a href="#react-advanced-patterns">4. Advanced Patterns</a>
            </li>
            <li style="margin-left: 20px">
              <a href="#react-performance">5. Performance Optimization</a>
            </li>
            <li style="margin-left: 20px">
              <a href="#react-interview">6. Interview Questions</a>
            </li>

            <li><strong>Part 2: Next.js App Router</strong></li>
            <li style="margin-left: 20px">
              <a href="#next-intro">1. Introduction to App Router</a>
            </li>
            <li style="margin-left: 20px">
              <a href="#next-routing">2. Routing System</a>
            </li>
            <li style="margin-left: 20px">
              <a href="#next-server-components">3. Server Components</a>
            </li>
            <li style="margin-left: 20px">
              <a href="#next-data-fetching">4. Data Fetching</a>
            </li>
            <li style="margin-left: 20px">
              <a href="#next-caching">5. Caching & Revalidation</a>
            </li>
            <li style="margin-left: 20px">
              <a href="#next-interview">6. Interview Questions</a>
            </li>
          </ul>
        </div>
      </div>

      <!-- PART 1: REACT.JS -->
      <div class="page">
        <h1>Part 1: React.js Deep Dive</h1>

        <h2 id="react-intro">1. Introduction to React</h2>
        <p>
          React is a JavaScript library for building user interfaces, developed
          and maintained by Meta (Facebook). It follows a component-based
          architecture and uses a declarative programming paradigm, making it
          easier to reason about application state and UI.
        </p>

        <h3>Core Philosophy</h3>
        <p>React's philosophy centers around three main principles:</p>
        <ul>
          <li>
            <strong>Declarative:</strong> You describe what the UI should look
            like for a given state, and React handles the DOM updates.
          </li>
          <li>
            <strong>Component-Based:</strong> Build encapsulated components that
            manage their own state, then compose them to create complex UIs.
          </li>
          <li>
            <strong>Learn Once, Write Anywhere:</strong> React doesn't make
            assumptions about your tech stack, allowing integration with
            existing codebases.
          </li>
        </ul>

        <h3>Virtual DOM</h3>
        <p>
          The Virtual DOM is React's secret weapon for performance. Instead of
          directly manipulating the browser's DOM (which is slow), React
          maintains an in-memory representation of the UI.
        </p>

        <div class="example">
          <h4>How Virtual DOM Works:</h4>
          <ol>
            <li>When state changes, React creates a new Virtual DOM tree</li>
            <li>
              React compares this new tree with the previous one (diffing)
            </li>
            <li>React calculates the minimal set of changes needed</li>
            <li>
              React updates only those specific parts in the real DOM
              (reconciliation)
            </li>
          </ol>
        </div>

        <h2 id="react-core-concepts">2. Core Concepts</h2>

        <h3>2.1 JSX (JavaScript XML)</h3>
        <p>
          JSX is a syntax extension that allows you to write HTML-like code in
          JavaScript. It's not required for React, but it makes code more
          readable and expressive.
        </p>

        <pre>
// JSX Example
const Welcome = ({ name }) => {
  return (
    &lt;div className="welcome"&gt;
      &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
      &lt;p&gt;Welcome to React&lt;/p&gt;
    &lt;/div&gt;
  );
};

// What JSX compiles to:
const Welcome = ({ name }) => {
  return React.createElement(
    'div',
    { className: 'welcome' },
    React.createElement('h1', null, `Hello, ${name}!`),
    React.createElement('p', null, 'Welcome to React')
  );
};
</pre
        >

        <h3>2.2 Components</h3>
        <p>
          Components are the building blocks of React applications. There are
          two types: functional and class components (functional are now
          preferred).
        </p>

        <pre>
// Functional Component
function UserProfile({ user }) {
  return (
    &lt;div className="profile"&gt;
      &lt;img src={user.avatar} alt={user.name} /&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.bio}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Class Component (Legacy)
class UserProfile extends React.Component {
  render() {
    const { user } = this.props;
    return (
      &lt;div className="profile"&gt;
        &lt;img src={user.avatar} alt={user.name} /&gt;
        &lt;h2&gt;{user.name}&lt;/h2&gt;
        &lt;p&gt;{user.bio}&lt;/p&gt;
      &lt;/div&gt;
    );
  }
}
</pre
        >
      </div>

      <div class="page">
        <h3>2.3 Props</h3>
        <p>
          Props (properties) are read-only inputs passed from parent to child
          components. They enable component reusability and composition.
        </p>

        <pre>
// Parent Component
function App() {
  const users = [
    { id: 1, name: 'Alice', role: 'Developer' },
    { id: 2, name: 'Bob', role: 'Designer' }
  ];

  return (
    &lt;div&gt;
      {users.map(user =&gt; (
        &lt;UserCard 
          key={user.id}
          name={user.name}
          role={user.role}
        /&gt;
      ))}
    &lt;/div&gt;
  );
}

// Child Component
function UserCard({ name, role }) {
  return (
    &lt;div className="card"&gt;
      &lt;h3&gt;{name}&lt;/h3&gt;
      &lt;p&gt;{role}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Props with default values
function Button({ text = 'Click me', onClick, variant = 'primary' }) {
  return (
    &lt;button 
      className={`btn btn-${variant}`}
      onClick={onClick}
    &gt;
      {text}
    &lt;/button&gt;
  );
}
</pre
        >

        <h3>2.4 State</h3>
        <p>
          State is mutable data that belongs to a component. When state changes,
          React re-renders the component and its children.
        </p>

        <pre>
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  const [step, setStep] = useState(1);

  const increment = () => setCount(count + step);
  const decrement = () => setCount(count - step);
  const reset = () => setCount(0);

  return (
    &lt;div&gt;
      &lt;h2&gt;Count: {count}&lt;/h2&gt;
      &lt;input 
        type="number" 
        value={step} 
        onChange={(e) =&gt; setStep(Number(e.target.value))}
      /&gt;
      &lt;button onClick={increment}&gt;+&lt;/button&gt;
      &lt;button onClick={decrement}&gt;-&lt;/button&gt;
      &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre
        >

        <div class="key-point">
          <h4>Important: State Updates are Asynchronous</h4>
          <p>
            React batches state updates for performance. If you need to update
            state based on previous state, use the functional form:
          </p>
          <pre>
// ‚ùå Wrong - may not work as expected
setCount(count + 1);
setCount(count + 1); // Still adds only 1

// ‚úÖ Correct
setCount(prevCount =&gt; prevCount + 1);
setCount(prevCount =&gt; prevCount + 1); // Adds 2
</pre
          >
        </div>

        <h2 id="react-hooks">3. Hooks in Detail</h2>

        <h3>3.1 useState</h3>
        <p>
          useState is the most fundamental hook for managing component state.
        </p>

        <pre>
function FormExample() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Form submitted:', formData);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        name="username"
        value={formData.username}
        onChange={handleChange}
        placeholder="Username"
      /&gt;
      &lt;input
        name="email"
        type="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Email"
      /&gt;
      &lt;input
        name="password"
        type="password"
        value={formData.password}
        onChange={handleChange}
        placeholder="Password"
      /&gt;
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}
</pre
        >
      </div>

      <div class="page">
        <h3>3.2 useEffect</h3>
        <p>
          useEffect handles side effects like data fetching, subscriptions, and
          manual DOM manipulation.
        </p>

        <pre>
import { useState, useEffect } from 'react';

function UserData({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // This runs after render
    let cancelled = false;

    const fetchUser = async () => {
      try {
        setLoading(true);
        const response = await fetch(`/api/users/${userId}`);
        const data = await response.json();
        
        if (!cancelled) {
          setUser(data);
          setError(null);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };

    fetchUser();

    // Cleanup function
    return () => {
      cancelled = true;
    };
  }, [userId]); // Runs when userId changes

  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  if (!user) return &lt;div&gt;No user found&lt;/div&gt;;

  return (
    &lt;div&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</pre
        >

        <div class="example">
          <h4>useEffect Dependency Array Rules:</h4>
          <ul>
            <li><strong>No array:</strong> Runs after every render</li>
            <li>
              <strong>Empty array []:</strong> Runs only once after initial
              render
            </li>
            <li>
              <strong>With dependencies [a, b]:</strong> Runs when a or b
              changes
            </li>
          </ul>
        </div>

        <h3>3.3 useContext</h3>
        <p>
          useContext provides a way to pass data through the component tree
          without manually passing props at every level.
        </p>

        <pre>
import { createContext, useContext, useState } from 'react';

// Create context
const ThemeContext = createContext();

// Provider component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// Custom hook to use theme
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// Consumer component
function ThemedButton() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    &lt;button 
      className={`btn-${theme}`}
      onClick={toggleTheme}
    &gt;
      Switch to {theme === 'light' ? 'dark' : 'light'} mode
    &lt;/button&gt;
  );
}

// App structure
function App() {
  return (
    &lt;ThemeProvider&gt;
      &lt;Header /&gt;
      &lt;Main /&gt;
      &lt;Footer /&gt;
    &lt;/ThemeProvider&gt;
  );
}
</pre
        >

        <h3>3.4 useReducer</h3>
        <p>
          useReducer is an alternative to useState for managing complex state
          logic.
        </p>

        <pre>
import { useReducer } from 'react';

// Define action types
const ACTIONS = {
  ADD_TODO: 'add_todo',
  TOGGLE_TODO: 'toggle_todo',
  DELETE_TODO: 'delete_todo'
};

// Reducer function
function todoReducer(state, action) {
  switch (action.type) {
    case ACTIONS.ADD_TODO:
      return [...state, {
        id: Date.now(),
        text: action.payload,
        completed: false
      }];
    
    case ACTIONS.TOGGLE_TODO:
      return state.map(todo =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    
    case ACTIONS.DELETE_TODO:
      return state.filter(todo => todo.id !== action.payload);
    
    default:
      return state;
  }
}

function TodoApp() {
  const [todos, dispatch] = useReducer(todoReducer, []);
  const [input, setInput] = useState('');

  const handleAdd = () => {
    if (input.trim()) {
      dispatch({ type: ACTIONS.ADD_TODO, payload: input });
      setInput('');
    }
  };

  return (
    &lt;div&gt;
      &lt;input 
        value={input}
        onChange={(e) =&gt; setInput(e.target.value)}
        onKeyPress={(e) =&gt; e.key === 'Enter' && handleAdd()}
      /&gt;
      &lt;button onClick={handleAdd}&gt;Add&lt;/button&gt;
      
      &lt;ul&gt;
        {todos.map(todo =&gt; (
          &lt;li key={todo.id}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() =&gt; dispatch({ 
                type: ACTIONS.TOGGLE_TODO, 
                payload: todo.id 
              })}
            /&gt;
            &lt;span style={{ 
              textDecoration: todo.completed ? 'line-through' : 'none' 
            }}&gt;
              {todo.text}
            &lt;/span&gt;
            &lt;button onClick={() =&gt; dispatch({ 
              type: ACTIONS.DELETE_TODO, 
              payload: todo.id 
            })}&gt;
              Delete
            &lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}
</pre
        >
      </div>

      <div class="page">
        <h3>3.5 useRef</h3>
        <p>
          useRef creates a mutable reference that persists across renders
          without causing re-renders when changed.
        </p>

        <pre>
import { useRef, useEffect } from 'react';

function TextInput() {
  const inputRef = useRef(null);
  const renderCount = useRef(0);

  useEffect(() => {
    renderCount.current += 1;
  });

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    &lt;div&gt;
      &lt;input ref={inputRef} type="text" /&gt;
      &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;
      &lt;p&gt;Render count: {renderCount.current}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Advanced useRef example: Previous value tracking
function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  }, [value]);
  
  return ref.current;
}

function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    &lt;div&gt;
      &lt;p&gt;Current: {count}&lt;/p&gt;
      &lt;p&gt;Previous: {prevCount}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre
        >

        <h3>3.6 useMemo</h3>
        <p>
          useMemo memoizes expensive computations, only recalculating when
          dependencies change.
        </p>

        <pre>
import { useMemo, useState } from 'react';

function ExpensiveComponent({ items, filter }) {
  const [sortOrder, setSortOrder] = useState('asc');

  // Expensive filtering and sorting
  const processedItems = useMemo(() => {
    console.log('Processing items...');
    
    const filtered = items.filter(item => 
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
    
    return filtered.sort((a, b) => {
      if (sortOrder === 'asc') {
        return a.price - b.price;
      }
      return b.price - a.price;
    });
  }, [items, filter, sortOrder]); // Only recalculate when these change

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; 
        setSortOrder(prev =&gt; prev === 'asc' ? 'desc' : 'asc')
      }&gt;
        Sort {sortOrder === 'asc' ? '‚Üë' : '‚Üì'}
      &lt;/button&gt;
      
      &lt;ul&gt;
        {processedItems.map(item =&gt; (
          &lt;li key={item.id}&gt;
            {item.name} - ${item.price}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}
</pre
        >

        <h3>3.7 useCallback</h3>
        <p>
          useCallback memoizes function references, preventing unnecessary
          re-renders of child components.
        </p>

        <pre>
import { useCallback, memo, useState } from 'react';

// Child component wrapped in memo
const ExpensiveChild = memo(({ onClick, id }) => {
  console.log(`Child ${id} rendered`);
  return &lt;button onClick={onClick}&gt;Click {id}&lt;/button&gt;;
});

function Parent() {
  const [count, setCount] = useState(0);
  const [otherState, setOtherState] = useState(0);

  // Without useCallback, this creates a new function on every render
  // causing ExpensiveChild to re-render
  const handleClick1 = useCallback(() => {
    console.log('Button 1 clicked');
  }, []); // Never changes

  const handleClick2 = useCallback(() => {
    console.log('Count is:', count);
  }, [count]); // Only changes when count changes

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
      &lt;button onClick={() =&gt; setOtherState(otherState + 1)}&gt;
        Update Other State
      &lt;/button&gt;
      
      &lt;ExpensiveChild onClick={handleClick1} id={1} /&gt;
      &lt;ExpensiveChild onClick={handleClick2} id={2} /&gt;
    &lt;/div&gt;
  );
}
</pre
        >

        <div class="key-point">
          <h4>When to Use useMemo vs useCallback?</h4>
          <ul>
            <li>
              <strong>useMemo:</strong> Memoize computed values (numbers,
              strings, arrays, objects)
            </li>
            <li><strong>useCallback:</strong> Memoize function references</li>
            <li>Both are optimization tools - don't use them prematurely</li>
            <li>Profile your app to identify actual performance bottlenecks</li>
          </ul>
        </div>
      </div>

      <div class="page">
        <h2 id="react-advanced-patterns">4. Advanced Patterns</h2>

        <h3>4.1 Custom Hooks</h3>
        <p>
          Custom hooks are reusable functions that can use React hooks
          internally. They must start with "use".
        </p>

        <pre>
// useLocalStorage hook
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function 
        ? value(storedValue) 
        : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}

// Usage
function App() {
  const [name, setName] = useLocalStorage('name', 'Anonymous');
  
  return (
    &lt;input 
      value={name}
      onChange={(e) =&gt; setName(e.target.value)}
    /&gt;
  );
}

// useFetch hook
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const abortController = new AbortController();

    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url, {
          signal: abortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const json = await response.json();
        setData(json);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    };

    fetchData();

    return () => abortController.abort();
  }, [url]);

  return { data, loading, error };
}

// Usage
function UserList() {
  const { data: users, loading, error } = useFetch('/api/users');

  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;

  return (
    &lt;ul&gt;
      {users.map(user =&gt; (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
</pre
        >

        <h3>4.2 Higher-Order Components (HOC)</h3>
        <p>
          HOCs are functions that take a component and return a new component
          with additional props or behavior.
        </p>

        <pre>
// HOC for adding loading state
function withLoading(Component) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return &lt;div&gt;Loading...&lt;/div&gt;;
    }
    return &lt;Component {...props} /&gt;;
  };
}

// Usage
const UserListWithLoading = withLoading(UserList);

// HOC for authentication
function withAuth(Component) {
  return function WithAuthComponent(props) {
    const { user, loading } = useAuth();

    if (loading) return &lt;div&gt;Checking authentication...&lt;/div&gt;;
    if (!user) return &lt;Navigate to="/login" /&gt;;

    return &lt;Component {...props} user={user} /&gt;;
  };
}

const ProtectedDashboard = withAuth(Dashboard);
</pre
        >

        <h3>4.3 Render Props Pattern</h3>
        <p>
          Render props is a technique for sharing code between components using
          a prop whose value is a function.
        </p>

        <pre>
function DataFetcher({ url, render }) {
  const { data, loading, error } = useFetch(url);

  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;

  return render(data);
}

// Usage
function App() {
  return (
    &lt;DataFetcher
      url="/api/users"
      render={(users) =&gt; (
        &lt;ul&gt;
          {users.map(user =&gt; (
            &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    /&gt;
  );
}

// Children as a function (variant)
function MouseTracker({ children }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  const handleMouseMove = (e) => {
    setPosition({ x: e.clientX, y: e.clientY });
  };

  return (
    &lt;div onMouseMove={handleMouseMove} style={{ height: '100vh' }}&gt;
      {children(position)}
    &lt;/div&gt;
  );
}

// Usage
&lt;MouseTracker&gt;
  {({ x, y }) =&gt; (
    &lt;p&gt;Mouse position: ({x}, {y})&lt;/p&gt;
  )}
&lt;/MouseTracker&gt;
</pre
        >
      </div>

      <div class="page">
        <h3>4.4 Compound Components</h3>
        <p>
          Compound components work together to form a complete UI component,
          sharing implicit state.
        </p>

        <pre>
// Create a context for shared state
const TabsContext = createContext();

function Tabs({ children, defaultValue }) {
  const [activeTab, setActiveTab] = useState(defaultValue);

  return (
    &lt;TabsContext.Provider value={{ activeTab, setActiveTab }}&gt;
      &lt;div className="tabs"&gt;{children}&lt;/div&gt;
    &lt;/TabsContext.Provider&gt;
  );
}

function TabList({ children }) {
  return &lt;div className="tab-list"&gt;{children}&lt;/div&gt;;
}

function Tab({ value, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  const isActive = activeTab === value;

  return (
    &lt;button
      className={`tab ${isActive ? 'active' : ''}`}
      onClick={() =&gt; setActiveTab(value)}
    &gt;
      {children}
    &lt;/button&gt;
  );
}

function TabPanel({ value, children }) {
  const { activeTab } = useContext(TabsContext);
  
  if (activeTab !== value) return null;
  
  return &lt;div className="tab-panel"&gt;{children}&lt;/div&gt;;
}

// Attach sub-components
Tabs.List = TabList;
Tabs.Tab = Tab;
Tabs.Panel = TabPanel;

// Usage
function App() {
  return (
    &lt;Tabs defaultValue="tab1"&gt;
      &lt;Tabs.List&gt;
        &lt;Tabs.Tab value="tab1"&gt;Profile&lt;/Tabs.Tab&gt;
        &lt;Tabs.Tab value="tab2"&gt;Settings&lt;/Tabs.Tab&gt;
        &lt;Tabs.Tab value="tab3"&gt;Messages&lt;/Tabs.Tab&gt;
      &lt;/Tabs.List&gt;

      &lt;Tabs.Panel value="tab1"&gt;
        &lt;h2&gt;Profile Content&lt;/h2&gt;
      &lt;/Tabs.Panel&gt;
      &lt;Tabs.Panel value="tab2"&gt;
        &lt;h2&gt;Settings Content&lt;/h2&gt;
      &lt;/Tabs.Panel&gt;
      &lt;Tabs.Panel value="tab3"&gt;
        &lt;h2&gt;Messages Content&lt;/h2&gt;
      &lt;/Tabs.Panel&gt;
    &lt;/Tabs&gt;
  );
}
</pre
        >

        <h2 id="react-performance">5. Performance Optimization</h2>

        <h3>5.1 React.memo</h3>
        <p>
          React.memo is a higher-order component that memoizes the result,
          preventing unnecessary re-renders.
        </p>

        <pre>
// Without memo - re-renders every time parent renders
function ListItem({ item }) {
  console.log('ListItem rendered');
  return &lt;li&gt;{item.name}&lt;/li&gt;;
}

// With memo - only re-renders when props change
const MemoizedListItem = memo(function ListItem({ item }) {
  console.log('ListItem rendered');
  return &lt;li&gt;{item.name}&lt;/li&gt;;
});

// Custom comparison function
const ListItemWithCustomCompare = memo(
  function ListItem({ item }) {
    return &lt;li&gt;{item.name} - ${item.price}&lt;/li&gt;;
  },
  (prevProps, nextProps) => {
    // Return true if props are equal (don't re-render)
    return prevProps.item.id === nextProps.item.id &&
           prevProps.item.price === nextProps.item.price;
  }
);
</pre
        >

        <h3>5.2 Code Splitting with React.lazy</h3>
        <p>
          React.lazy enables dynamic imports for code splitting, reducing
          initial bundle size.
        </p>

        <pre>
import { lazy, Suspense } from 'react';

// Lazy load components
const Dashboard = lazy(() =&gt; import('./Dashboard'));
const Profile = lazy(() =&gt; import('./Profile'));
const Settings = lazy(() =&gt; import('./Settings'));

function App() {
  return (
    &lt;Router&gt;
      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;Routes&gt;
          &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
          &lt;Route path="/dashboard" element={&lt;Dashboard /&gt;} /&gt;
          &lt;Route path="/profile" element={&lt;Profile /&gt;} /&gt;
          &lt;Route path="/settings" element={&lt;Settings /&gt;} /&gt;
        &lt;/Routes&gt;
      &lt;/Suspense&gt;
    &lt;/Router&gt;
  );
}

// Named exports with lazy loading
const { UserProfile } = lazy(() =&gt; 
  import('./components').then(module =&gt; ({
    default: { UserProfile: module.UserProfile }
  }))
);
</pre
        >

        <h3>5.3 Virtualization</h3>
        <p>
          For rendering large lists, virtualization only renders visible items.
        </p>

        <pre>
// Simple virtualization implementation
function VirtualList({ items, itemHeight, containerHeight }) {
  const [scrollTop, setScrollTop] = useState(0);

  const visibleStart = Math.floor(scrollTop / itemHeight);
  const visibleEnd = Math.ceil((scrollTop + containerHeight) / itemHeight);

  const visibleItems = items.slice(visibleStart, visibleEnd);
  const offsetY = visibleStart * itemHeight;

  return (
    &lt;div
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) =&gt; setScrollTop(e.target.scrollTop)}
    &gt;
      &lt;div style={{ height: items.length * itemHeight }}&gt;
        &lt;div style={{ transform: `translateY(${offsetY}px)` }}&gt;
          {visibleItems.map((item, index) =&gt; (
            &lt;div 
              key={visibleStart + index} 
              style={{ height: itemHeight }}
            &gt;
              {item.name}
            &lt;/div&gt;
          ))}
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Usage with react-window library (recommended)
import { FixedSizeList } from 'react-window';

function App() {
  const items = Array.from({ length: 10000 }, (_, i) =&gt; ({
    id: i,
    name: `Item ${i}`
  }));

  const Row = ({ index, style }) =&gt; (
    &lt;div style={style}&gt;
      {items[index].name}
    &lt;/div&gt;
  );

  return (
    &lt;FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    &gt;
      {Row}
    &lt;/FixedSizeList&gt;
  );
}
</pre
        >
      </div>

      <div class="page">
        <h3>5.4 Debouncing and Throttling</h3>
        <p>Optimize expensive operations by limiting how often they execute.</p>

        <pre>
// Custom debounce hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

// Usage in search
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      // API call only happens 500ms after user stops typing
      fetch(`/api/search?q=${debouncedSearchTerm}`)
        .then(res =&gt; res.json())
        .then(setResults);
    }
  }, [debouncedSearchTerm]);

  return (
    &lt;input
      value={searchTerm}
      onChange={(e) =&gt; setSearchTerm(e.target.value)}
      placeholder="Search..."
    /&gt;
  );
}

// Throttle hook
function useThrottle(callback, delay) {
  const lastRun = useRef(Date.now());

  return useCallback((...args) => {
    const now = Date.now();
    if (now - lastRun.current >= delay) {
      callback(...args);
      lastRun.current = now;
    }
  }, [callback, delay]);
}

// Usage for scroll events
function ScrollComponent() {
  const [scrollPosition, setScrollPosition] = useState(0);

  const handleScroll = useThrottle(() => {
    setScrollPosition(window.scrollY);
  }, 100); // Update at most every 100ms

  useEffect(() => {
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [handleScroll]);

  return &lt;div&gt;Scroll position: {scrollPosition}&lt;/div&gt;;
}
</pre
        >

        <h2 id="react-interview">6. React Interview Questions</h2>

        <div class="question">
          <h4>Q1: What is the Virtual DOM and how does React use it?</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> The Virtual DOM is a lightweight JavaScript
            representation of the actual DOM. React maintains this in-memory
            structure to optimize rendering.
          </p>
          <p><strong>Process:</strong></p>
          <ol>
            <li>When state changes, React creates a new Virtual DOM tree</li>
            <li>
              React compares it with the previous Virtual DOM
              (diffing/reconciliation)
            </li>
            <li>React calculates the minimal set of changes needed</li>
            <li>
              React updates only those specific parts in the real DOM (batched
              updates)
            </li>
          </ol>
          <p>
            <strong>Benefits:</strong> Minimizes expensive DOM operations,
            enables efficient updates, and improves performance for complex UIs.
          </p>
        </div>

        <div class="question">
          <h4>
            Q2: Explain the difference between controlled and uncontrolled
            components.
          </h4>
        </div>
        <div class="answer">
          <p>
            <strong>Controlled Components:</strong> Form data is handled by
            React state. The component's value is controlled by React.
          </p>
          <pre>
function ControlledInput() {
  const [value, setValue] = useState('');
  return (
    &lt;input 
      value={value} 
      onChange={(e) =&gt; setValue(e.target.value)} 
    /&gt;
  );
}
</pre
          >
          <p>
            <strong>Uncontrolled Components:</strong> Form data is handled by
            the DOM itself. Access values using refs.
          </p>
          <pre>
function UncontrolledInput() {
  const inputRef = useRef();
  const handleSubmit = () =&gt; {
    console.log(inputRef.current.value);
  };
  return &lt;input ref={inputRef} /&gt;;
}
</pre
          >
          <p>
            <strong>When to use:</strong> Controlled for most cases (validation,
            dynamic updates). Uncontrolled for file inputs or integrating with
            non-React code.
          </p>
        </div>

        <div class="question">
          <h4>Q3: What are React keys and why are they important?</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> Keys help React identify which items have
            changed, been added, or removed in lists. They should be stable,
            unique identifiers.
          </p>
          <pre>
// ‚ùå Bad - using index
{items.map((item, index) =&gt; (
  &lt;div key={index}&gt;{item.name}&lt;/div&gt;
))}

// ‚úÖ Good - using unique ID
{items.map(item =&gt; (
  &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;
))}
</pre
          >
          <p><strong>Why important:</strong></p>
          <ul>
            <li>Helps React optimize re-renders by reusing DOM elements</li>
            <li>Prevents bugs when list order changes</li>
            <li>Maintains component state correctly</li>
            <li>Using index as key can cause issues with dynamic lists</li>
          </ul>
        </div>
      </div>

      <div class="page">
        <div class="question">
          <h4>Q4: Explain React's reconciliation algorithm.</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> Reconciliation is the algorithm React uses
            to diff one tree with another to determine what needs to be changed.
          </p>
          <p><strong>Key principles:</strong></p>
          <ul>
            <li>
              <strong>Different element types:</strong> React tears down the old
              tree and builds new one
            </li>
            <li>
              <strong>Same element type:</strong> React keeps the same DOM node
              and updates changed attributes
            </li>
            <li>
              <strong>Keys:</strong> React uses keys to match children in the
              original tree with children in the subsequent tree
            </li>
            <li>
              <strong>Breadth-first:</strong> Compares elements level by level
            </li>
          </ul>
          <p>
            <strong>Time complexity:</strong> O(n) instead of O(n¬≥) for
            traditional tree diff algorithms
          </p>
        </div>

        <div class="question">
          <h4>Q5: What is the difference between useMemo and useCallback?</h4>
        </div>
        <div class="answer">
          <p><strong>useMemo:</strong> Memoizes a computed value</p>
          <pre>
const expensiveValue = useMemo(() =&gt; {
  return computeExpensiveValue(a, b);
}, [a, b]);
</pre
          >
          <p><strong>useCallback:</strong> Memoizes a function definition</p>
          <pre>
const memoizedCallback = useCallback(() =&gt; {
  doSomething(a, b);
}, [a, b]);
</pre
          >
          <p>
            <strong>Relationship:</strong> <code>useCallback(fn, deps)</code> is
            equivalent to <code>useMemo(() => fn, deps)</code>
          </p>
          <p><strong>When to use:</strong></p>
          <ul>
            <li>useMemo: Expensive calculations, derived data</li>
            <li>
              useCallback: Passing callbacks to optimized child components that
              rely on reference equality
            </li>
          </ul>
        </div>

        <div class="question">
          <h4>
            Q6: Explain closure issues in useEffect and how to solve them.
          </h4>
        </div>
        <div class="answer">
          <p>
            <strong>Problem:</strong> Functions inside useEffect capture values
            from when the effect was created (stale closures).
          </p>
          <pre>
// ‚ùå Bug: count is always 0 in the interval
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // Always uses initial count (0)
    }, 1000);
    return () => clearInterval(id);
  }, []); // Empty deps

  return &lt;div&gt;{count}&lt;/div&gt;;
}

// ‚úÖ Solution 1: Functional update
setCount(prevCount =&gt; prevCount + 1);

// ‚úÖ Solution 2: Include dependency
useEffect(() => {
  const id = setInterval(() => {
    setCount(count + 1);
  }, 1000);
  return () => clearInterval(id);
}, [count]); // Include count

// ‚úÖ Solution 3: useRef for mutable values
const countRef = useRef(count);
countRef.current = count;
</pre
          >
        </div>

        <div class="question">
          <h4>Q7: What are React Portals and when would you use them?</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> Portals provide a way to render children
            into a DOM node outside the parent component's DOM hierarchy.
          </p>
          <pre>
import { createPortal } from 'react-dom';

function Modal({ children, isOpen }) {
  if (!isOpen) return null;

  return createPortal(
    &lt;div className="modal-overlay"&gt;
      &lt;div className="modal"&gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;,
    document.getElementById('modal-root')
  );
}
</pre
          >
          <p><strong>Use cases:</strong></p>
          <ul>
            <li>Modals and dialogs</li>
            <li>Tooltips</li>
            <li>Popovers</li>
            <li>Notifications/Toasts</li>
            <li>Any component that needs to break out of overflow:hidden</li>
          </ul>
          <p>
            <strong>Benefits:</strong> Event bubbling works through portals,
            maintains React context, avoids z-index and overflow issues.
          </p>
        </div>

        <div class="question">
          <h4>Q8: Explain Error Boundaries in React.</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> Error Boundaries are React components that
            catch JavaScript errors anywhere in their child component tree, log
            those errors, and display a fallback UI.
          </p>
          <pre>
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.log('Error:', error);
    console.log('Error Info:', errorInfo);
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
    }
    return this.props.children;
  }
}

// Usage
&lt;ErrorBoundary&gt;
  &lt;MyComponent /&gt;
&lt;/ErrorBoundary&gt;
</pre
          >
          <p><strong>What they DON'T catch:</strong></p>
          <ul>
            <li>Event handlers (use try-catch)</li>
            <li>Asynchronous code</li>
            <li>Server-side rendering</li>
            <li>Errors in the error boundary itself</li>
          </ul>
        </div>
      </div>

      <div class="page">
        <div class="question">
          <h4>Q9: What is React Context and when should you use it?</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> Context provides a way to pass data through
            the component tree without having to pass props down manually at
            every level.
          </p>
          <p><strong>When to use:</strong></p>
          <ul>
            <li>Theme data (light/dark mode)</li>
            <li>User authentication state</li>
            <li>Preferred language</li>
            <li>Any data that many components need access to</li>
          </ul>
          <p><strong>When NOT to use:</strong></p>
          <ul>
            <li>
              Just to avoid passing props a few levels deep (composition is
              better)
            </li>
            <li>High-frequency updates (causes all consumers to re-render)</li>
            <li>Complex state management (consider Redux, Zustand, etc.)</li>
          </ul>
          <p>
            <strong>Performance tip:</strong> Split contexts to avoid
            unnecessary re-renders
          </p>
          <pre>
// ‚ùå One context for everything
const AppContext = { user, theme, settings };

// ‚úÖ Split contexts
const UserContext = { user };
const ThemeContext = { theme };
const SettingsContext = { settings };
</pre
          >
        </div>

        <div class="question">
          <h4>
            Q10: Explain the useLayoutEffect hook and its differences from
            useEffect.
          </h4>
        </div>
        <div class="answer">
          <p>
            <strong>useEffect:</strong> Runs asynchronously after paint. Doesn't
            block browser painting.
          </p>
          <p>
            <strong>useLayoutEffect:</strong> Runs synchronously after all DOM
            mutations but before paint. Blocks visual updates.
          </p>
          <pre>
// Execution order:
// 1. React updates DOM
// 2. useLayoutEffect runs (synchronously)
// 3. Browser paints
// 4. useEffect runs (asynchronously)

// Use useLayoutEffect when:
function Component() {
  const ref = useRef();

  useLayoutEffect(() => {
    // Measure DOM node
    const rect = ref.current.getBoundingClientRect();
    
    // Update state based on measurement
    // This prevents visual flicker
    setPosition(rect.top);
  }, []);

  return &lt;div ref={ref}&gt;Content&lt;/div&gt;;
}
</pre
          >
          <p><strong>Use cases for useLayoutEffect:</strong></p>
          <ul>
            <li>DOM measurements (getBoundingClientRect)</li>
            <li>Synchronous DOM updates before paint</li>
            <li>Preventing visual flicker</li>
            <li>Scroll position restoration</li>
          </ul>
          <p>
            <strong>Default to useEffect</strong> - only use useLayoutEffect if
            you see visual flickering or need DOM measurements.
          </p>
        </div>

        <div class="question">
          <h4>Q11: How does React Fiber improve React's performance?</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> React Fiber is a complete rewrite of
            React's reconciliation algorithm introduced in React 16.
          </p>
          <p><strong>Key improvements:</strong></p>
          <ul>
            <li>
              <strong>Incremental rendering:</strong> Split rendering work into
              chunks and spread it over multiple frames
            </li>
            <li>
              <strong>Ability to pause/resume work:</strong> Can interrupt
              rendering to handle high-priority updates
            </li>
            <li>
              <strong>Priority-based rendering:</strong> Different updates have
              different priorities (user input > animations > data fetching)
            </li>
            <li>
              <strong>Concurrent rendering:</strong> Prepare multiple versions
              of the UI simultaneously
            </li>
          </ul>
          <p><strong>Benefits:</strong></p>
          <ul>
            <li>Better responsiveness for user interactions</li>
            <li>Smoother animations</li>
            <li>Better handling of large component trees</li>
            <li>Foundation for Concurrent Mode and Suspense</li>
          </ul>
        </div>

        <div class="question">
          <h4>Q12: Explain React's Strict Mode and its benefits.</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> StrictMode is a development tool that helps
            identify potential problems in an application.
          </p>
          <pre>
&lt;React.StrictMode&gt;
  &lt;App /&gt;
&lt;/React.StrictMode&gt;
</pre
          >
          <p><strong>What it does:</strong></p>
          <ul>
            <li>
              <strong>Double invocation:</strong> Renders components twice to
              detect side effects
            </li>
            <li>
              <strong>Warns about deprecated APIs:</strong> Legacy lifecycle
              methods, findDOMNode, legacy context API
            </li>
            <li>
              <strong>Detects unexpected side effects:</strong> In render phase,
              constructor, getDerivedStateFromProps
            </li>
            <li><strong>Warns about legacy ref API:</strong> String refs</li>
          </ul>
          <p>
            <strong>Important:</strong> Only runs in development mode, has no
            effect in production.
          </p>
        </div>
      </div>

      <!-- PART 2: NEXT.JS APP ROUTER -->
      <div class="page">
        <h1>Part 2: Next.js App Router Deep Dive</h1>

        <h2 id="next-intro">1. Introduction to App Router</h2>
        <p>
          The App Router is a new paradigm in Next.js 13+ that introduces a
          file-system based router built on React Server Components. It
          represents a fundamental shift in how Next.js applications are
          structured and rendered.
        </p>

        <h3>Why App Router?</h3>
        <p>
          The App Router was created to solve several limitations of the Pages
          Router:
        </p>
        <ul>
          <li>
            <strong>Better data fetching:</strong> Fetch data where you need it,
            in the component itself
          </li>
          <li>
            <strong>Server Components by default:</strong> Smaller bundle sizes,
            better performance
          </li>
          <li>
            <strong>Improved layouts:</strong> Nested layouts that preserve
            state
          </li>
          <li>
            <strong>Better streaming:</strong> Progressive rendering with React
            Suspense
          </li>
          <li><strong>Colocation:</strong> Keep related code together</li>
        </ul>

        <h3>App Router vs Pages Router</h3>
        <div class="example">
          <table style="width: 100%; border-collapse: collapse">
            <tr>
              <th
                style="
                  border: 1px solid #ddd;
                  padding: 8px;
                  background: #f2f2f2;
                "
              >
                Feature
              </th>
              <th
                style="
                  border: 1px solid #ddd;
                  padding: 8px;
                  background: #f2f2f2;
                "
              >
                Pages Router
              </th>
              <th
                style="
                  border: 1px solid #ddd;
                  padding: 8px;
                  background: #f2f2f2;
                "
              >
                App Router
              </th>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">Directory</td>
              <td style="border: 1px solid #ddd; padding: 8px">/pages</td>
              <td style="border: 1px solid #ddd; padding: 8px">/app</td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">Default</td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Client Components
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Server Components
              </td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">
                Data Fetching
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">
                getServerSideProps, getStaticProps
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">
                async/await in components
              </td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">Layouts</td>
              <td style="border: 1px solid #ddd; padding: 8px">
                _app.js (single layout)
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Nested layouts with layout.js
              </td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">
                Loading States
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Manual implementation
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">
                loading.js convention
              </td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">
                Error Handling
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">_error.js</td>
              <td style="border: 1px solid #ddd; padding: 8px">
                error.js (per route)
              </td>
            </tr>
          </table>
        </div>

        <h2 id="next-routing">2. Routing System</h2>

        <h3>2.1 File-System Based Routing</h3>
        <p>
          The App Router uses a folder-based routing system where folders define
          routes and special files define UI.
        </p>

        <pre>
app/
‚îú‚îÄ‚îÄ page.js                    // Route: /
‚îú‚îÄ‚îÄ layout.js                  // Root layout
‚îú‚îÄ‚îÄ loading.js                 // Root loading UI
‚îú‚îÄ‚îÄ error.js                   // Root error UI
‚îú‚îÄ‚îÄ about/
‚îÇ   ‚îî‚îÄ‚îÄ page.js               // Route: /about
‚îú‚îÄ‚îÄ blog/
‚îÇ   ‚îú‚îÄ‚îÄ page.js               // Route: /blog
‚îÇ   ‚îú‚îÄ‚îÄ [slug]/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.js           // Route: /blog/[slug]
‚îÇ   ‚îî‚îÄ‚îÄ layout.js             // Layout for /blog/*
‚îî‚îÄ‚îÄ dashboard/
    ‚îú‚îÄ‚îÄ layout.js             // Dashboard layout
    ‚îú‚îÄ‚îÄ page.js               // Route: /dashboard
    ‚îú‚îÄ‚îÄ settings/
    ‚îÇ   ‚îî‚îÄ‚îÄ page.js           // Route: /dashboard/settings
    ‚îî‚îÄ‚îÄ profile/
        ‚îî‚îÄ‚îÄ page.js           // Route: /dashboard/profile
</pre
        >

        <h3>2.2 Special Files</h3>
        <div class="example">
          <ul>
            <li>
              <strong>page.js:</strong> Makes route publicly accessible, defines
              the UI
            </li>
            <li>
              <strong>layout.js:</strong> Shared UI for a segment and its
              children
            </li>
            <li>
              <strong>loading.js:</strong> Loading UI wrapped in Suspense
              boundary
            </li>
            <li>
              <strong>error.js:</strong> Error UI wrapped in Error boundary
            </li>
            <li><strong>not-found.js:</strong> UI for 404 errors</li>
            <li>
              <strong>template.js:</strong> Re-rendered layout (doesn't preserve
              state)
            </li>
            <li><strong>route.js:</strong> API endpoint (Route Handler)</li>
          </ul>
        </div>

        <h3>2.3 Page.js Example</h3>
        <pre>
// app/page.js
export default function HomePage() {
  return (
    &lt;main&gt;
      &lt;h1&gt;Welcome to Next.js&lt;/h1&gt;
      &lt;p&gt;This is the home page&lt;/p&gt;
    &lt;/main&gt;
  );
}

// app/blog/page.js
export default function BlogPage() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Blog&lt;/h1&gt;
      &lt;p&gt;List of blog posts&lt;/p&gt;
    &lt;/div&gt;
  );
}

// With metadata
export const metadata = {
  title: 'Blog',
  description: 'Read our latest blog posts',
};
</pre
        >

        <h3>2.4 Dynamic Routes</h3>
        <pre>
// app/blog/[slug]/page.js
export default function BlogPost({ params }) {
  return (
    &lt;article&gt;
      &lt;h1&gt;Post: {params.slug}&lt;/h1&gt;
    &lt;/article&gt;
  );
}

// Catch-all routes: app/shop/[...slug]/page.js
// Matches: /shop/a, /shop/a/b, /shop/a/b/c
export default function ShopPage({ params }) {
  // params.slug will be an array: ['a', 'b', 'c']
  return &lt;div&gt;Category: {params.slug.join('/')}&lt;/div&gt;;
}

// Optional catch-all: app/docs/[[...slug]]/page.js
// Matches: /docs, /docs/a, /docs/a/b
export default function DocsPage({ params }) {
  const slug = params.slug || [];
  return &lt;div&gt;Docs: {slug.join('/') || 'Home'}&lt;/div&gt;;
}
</pre
        >
      </div>

      <div class="page">
        <h3>2.5 Layouts</h3>
        <p>
          Layouts are UI that wrap pages and preserve state during navigation.
        </p>

        <pre>
// app/layout.js (Root Layout - Required)
export default function RootLayout({ children }) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;
        &lt;header&gt;
          &lt;nav&gt;
            &lt;a href="/"&gt;Home&lt;/a&gt;
            &lt;a href="/blog"&gt;Blog&lt;/a&gt;
          &lt;/nav&gt;
        &lt;/header&gt;
        {children}
        &lt;footer&gt;¬© 2024&lt;/footer&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}

// app/dashboard/layout.js (Nested Layout)
export default function DashboardLayout({ children }) {
  return (
    &lt;div className="dashboard"&gt;
      &lt;aside&gt;
        &lt;nav&gt;
          &lt;a href="/dashboard"&gt;Overview&lt;/a&gt;
          &lt;a href="/dashboard/settings"&gt;Settings&lt;/a&gt;
          &lt;a href="/dashboard/profile"&gt;Profile&lt;/a&gt;
        &lt;/nav&gt;
      &lt;/aside&gt;
      &lt;main&gt;{children}&lt;/main&gt;
    &lt;/div&gt;
  );
}

// Layout with data fetching
async function getUser() {
  const res = await fetch('https://api.example.com/user');
  return res.json();
}

export default async function ProfileLayout({ children }) {
  const user = await getUser();
  
  return (
    &lt;div&gt;
      &lt;div className="profile-header"&gt;
        &lt;img src={user.avatar} alt={user.name} /&gt;
        &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;/div&gt;
      {children}
    &lt;/div&gt;
  );
}
</pre
        >

        <h3>2.6 Loading UI</h3>
        <pre>
// app/blog/loading.js
export default function Loading() {
  return (
    &lt;div className="loading"&gt;
      &lt;div className="spinner"&gt;&lt;/div&gt;
      &lt;p&gt;Loading blog posts...&lt;/p&gt;
    &lt;/div&gt;
  );
}

// app/dashboard/loading.js
export default function DashboardLoading() {
  return (
    &lt;div className="skeleton"&gt;
      &lt;div className="skeleton-header"&gt;&lt;/div&gt;
      &lt;div className="skeleton-content"&gt;&lt;/div&gt;
      &lt;div className="skeleton-footer"&gt;&lt;/div&gt;
    &lt;/div&gt;
  );
}

// How it works:
// loading.js automatically wraps page.js in a Suspense boundary
// Equivalent to:
// &lt;Suspense fallback={&lt;Loading /&gt;}&gt;
//   &lt;Page /&gt;
// &lt;/Suspense&gt;
</pre
        >

        <h3>2.7 Error Handling</h3>
        <pre>
// app/error.js
'use client'; // Error components must be Client Components

export default function Error({ error, reset }) {
  return (
    &lt;div&gt;
      &lt;h2&gt;Something went wrong!&lt;/h2&gt;
      &lt;p&gt;{error.message}&lt;/p&gt;
      &lt;button onClick={reset}&gt;Try again&lt;/button&gt;
    &lt;/div&gt;
  );
}

// app/blog/error.js (Scoped error handling)
'use client';

import { useEffect } from 'react';

export default function BlogError({ error, reset }) {
  useEffect(() => {
    // Log to error reporting service
    console.error('Blog error:', error);
  }, [error]);

  return (
    &lt;div className="error-container"&gt;
      &lt;h2&gt;Failed to load blog posts&lt;/h2&gt;
      &lt;p&gt;{error.message}&lt;/p&gt;
      &lt;button onClick={reset}&gt;Reload&lt;/button&gt;
    &lt;/div&gt;
  );
}

// app/not-found.js
export default function NotFound() {
  return (
    &lt;div&gt;
      &lt;h2&gt;404 - Page Not Found&lt;/h2&gt;
      &lt;p&gt;Could not find requested resource&lt;/p&gt;
      &lt;a href="/"&gt;Return Home&lt;/a&gt;
    &lt;/div&gt;
  );
}
</pre
        >

        <h2 id="next-server-components">3. Server Components</h2>
        <p>
          React Server Components (RSC) are the default in the App Router. They
          run on the server and can directly access backend resources.
        </p>

        <h3>3.1 Server vs Client Components</h3>
        <div class="example">
          <h4>Server Components (Default):</h4>
          <ul>
            <li>Fetch data on the server</li>
            <li>Access backend resources directly</li>
            <li>Keep sensitive information on server (API keys, tokens)</li>
            <li>Reduce client-side JavaScript</li>
            <li>Cannot use hooks (useState, useEffect)</li>
            <li>Cannot use browser APIs</li>
            <li>Cannot use event handlers</li>
          </ul>

          <h4>Client Components ('use client'):</h4>
          <ul>
            <li>Add interactivity (event handlers)</li>
            <li>Use State and Lifecycle Hooks</li>
            <li>Use browser APIs</li>
            <li>Use custom hooks</li>
            <li>Use Context</li>
          </ul>
        </div>
      </div>

      <div class="page">
        <h3>3.2 Server Component Examples</h3>
        <pre>
// app/products/page.js (Server Component)
async function getProducts() {
  // Direct database access - no API route needed
  const res = await fetch('https://api.example.com/products', {
    cache: 'no-store', // Always fresh
  });
  return res.json();
}

export default async function ProductsPage() {
  const products = await getProducts();
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Products&lt;/h1&gt;
      {products.map(product =&gt; (
        &lt;ProductCard key={product.id} product={product} /&gt;
      ))}
    &lt;/div&gt;
  );
}

// Parallel data fetching
async function getUser() {
  const res = await fetch('https://api.example.com/user');
  return res.json();
}

async function getPosts() {
  const res = await fetch('https://api.example.com/posts');
  return res.json();
}

export default async function ProfilePage() {
  // Fetch in parallel
  const [user, posts] = await Promise.all([
    getUser(),
    getPosts(),
  ]);

  return (
    &lt;div&gt;
      &lt;UserProfile user={user} /&gt;
      &lt;PostsList posts={posts} /&gt;
    &lt;/div&gt;
  );
}
</pre
        >

        <h3>3.3 Client Component Examples</h3>
        <pre>
// components/Counter.js
'use client'; // This directive marks it as a Client Component

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// components/SearchBar.js
'use client';

import { useState, useEffect } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';

export default function SearchBar() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [query, setQuery] = useState(searchParams.get('q') || '');

  const handleSearch = (e) => {
    e.preventDefault();
    router.push(`/search?q=${encodeURIComponent(query)}`);
  };

  return (
    &lt;form onSubmit={handleSearch}&gt;
      &lt;input
        value={query}
        onChange={(e) =&gt; setQuery(e.target.value)}
        placeholder="Search..."
      /&gt;
      &lt;button type="submit"&gt;Search&lt;/button&gt;
    &lt;/form&gt;
  );
}
</pre
        >

        <h3>3.4 Composing Server and Client Components</h3>
        <pre>
// app/page.js (Server Component)
import ClientComponent from './ClientComponent';
import ServerComponent from './ServerComponent';

async function getData() {
  const res = await fetch('https://api.example.com/data');
  return res.json();
}

export default async function Page() {
  const data = await getData();

  return (
    &lt;div&gt;
      {/* Server Component */}
      &lt;ServerComponent data={data} /&gt;
      
      {/* Client Component */}
      &lt;ClientComponent initialData={data} /&gt;
      
      {/* Passing Server Component as children to Client Component */}
      &lt;ClientWrapper&gt;
        &lt;ServerComponent data={data} /&gt;
      &lt;/ClientWrapper&gt;
    &lt;/div&gt;
  );
}

// ClientWrapper.js
'use client';

export default function ClientWrapper({ children }) {
  return (
    &lt;div className="wrapper"&gt;
      {/* children can be Server Components */}
      {children}
    &lt;/div&gt;
  );
}
</pre
        >

        <div class="key-point">
          <h4>Important Rules:</h4>
          <ul>
            <li>
              You cannot import Server Components into Client Components
              directly
            </li>
            <li>
              You CAN pass Server Components as children/props to Client
              Components
            </li>
            <li>
              Once you use 'use client', all imported components become Client
              Components
            </li>
            <li>Keep Client Components at the leaves of your component tree</li>
          </ul>
        </div>

        <h2 id="next-data-fetching">4. Data Fetching</h2>

        <h3>4.1 Async Components</h3>
        <p>
          Server Components can be async, making data fetching straightforward.
        </p>

        <pre>
// app/posts/page.js
async function getPosts() {
  const res = await fetch('https://api.example.com/posts', {
    next: { revalidate: 60 } // Revalidate every 60 seconds
  });
  
  if (!res.ok) {
    throw new Error('Failed to fetch posts');
  }
  
  return res.json();
}

export default async function PostsPage() {
  const posts = await getPosts();

  return (
    &lt;div&gt;
      &lt;h1&gt;Blog Posts&lt;/h1&gt;
      {posts.map(post =&gt; (
        &lt;article key={post.id}&gt;
          &lt;h2&gt;{post.title}&lt;/h2&gt;
          &lt;p&gt;{post.excerpt}&lt;/p&gt;
        &lt;/article&gt;
      ))}
    &lt;/div&gt;
  );
}
</pre
        >
      </div>

      <div class="page">
        <h3>4.2 Streaming with Suspense</h3>
        <pre>
// app/dashboard/page.js
import { Suspense } from 'react';

async function Revenue() {
  const data = await fetch('https://api.example.com/revenue');
  const revenue = await data.json();
  
  return (
    &lt;div className="card"&gt;
      &lt;h3&gt;Revenue&lt;/h3&gt;
      &lt;p&gt;${revenue.total}&lt;/p&gt;
    &lt;/div&gt;
  );
}

async function Orders() {
  const data = await fetch('https://api.example.com/orders');
  const orders = await data.json();
  
  return (
    &lt;div className="card"&gt;
      &lt;h3&gt;Orders&lt;/h3&gt;
      &lt;p&gt;{orders.count} orders&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default function Dashboard() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Dashboard&lt;/h1&gt;
      
      {/* Stream Revenue independently */}
      &lt;Suspense fallback={&lt;CardSkeleton /&gt;}&gt;
        &lt;Revenue /&gt;
      &lt;/Suspense&gt;
      
      {/* Stream Orders independently */}
      &lt;Suspense fallback={&lt;CardSkeleton /&gt;}&gt;
        &lt;Orders /&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  );
}

function CardSkeleton() {
  return (
    &lt;div className="card skeleton"&gt;
      &lt;div className="skeleton-title"&gt;&lt;/div&gt;
      &lt;div className="skeleton-text"&gt;&lt;/div&gt;
    &lt;/div&gt;
  );
}
</pre
        >

        <h3>4.3 Route Handlers (API Routes)</h3>
        <pre>
// app/api/users/route.js
import { NextResponse } from 'next/server';

// GET /api/users
export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = searchParams.get('page') || '1';
  
  const users = await fetchUsers(page);
  
  return NextResponse.json({ users });
}

// POST /api/users
export async function POST(request) {
  const body = await request.json();
  const user = await createUser(body);
  
  return NextResponse.json(
    { user },
    { status: 201 }
  );
}

// app/api/users/[id]/route.js
export async function GET(request, { params }) {
  const user = await fetchUser(params.id);
  
  if (!user) {
    return NextResponse.json(
      { error: 'User not found' },
      { status: 404 }
    );
  }
  
  return NextResponse.json({ user });
}

export async function PUT(request, { params }) {
  const body = await request.json();
  const user = await updateUser(params.id, body);
  
  return NextResponse.json({ user });
}

export async function DELETE(request, { params }) {
  await deleteUser(params.id);
  
  return NextResponse.json(
    { message: 'User deleted' },
    { status: 200 }
  );
}
</pre
        >

        <h3>4.4 Server Actions</h3>
        <p>
          Server Actions allow you to run server code directly from Client
          Components.
        </p>

        <pre>
// app/actions.js
'use server';

import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';

export async function createPost(formData) {
  const title = formData.get('title');
  const content = formData.get('content');
  
  // Validate
  if (!title || !content) {
    return { error: 'Title and content are required' };
  }
  
  // Save to database
  const post = await db.posts.create({
    data: { title, content }
  });
  
  // Revalidate the posts page
  revalidatePath('/posts');
  
  // Redirect to the new post
  redirect(`/posts/${post.id}`);
}

export async function updatePost(postId, formData) {
  const title = formData.get('title');
  const content = formData.get('content');
  
  await db.posts.update({
    where: { id: postId },
    data: { title, content }
  });
  
  revalidatePath(`/posts/${postId}`);
  return { success: true };
}

export async function deletePost(postId) {
  await db.posts.delete({
    where: { id: postId }
  });
  
  revalidatePath('/posts');
  redirect('/posts');
}

// app/posts/new/page.js
import { createPost } from '../actions';

export default function NewPostPage() {
  return (
    &lt;form action={createPost}&gt;
      &lt;input name="title" placeholder="Title" required /&gt;
      &lt;textarea name="content" placeholder="Content" required /&gt;
      &lt;button type="submit"&gt;Create Post&lt;/button&gt;
    &lt;/form&gt;
  );
}

// Using Server Actions in Client Components
// components/PostForm.js
'use client';

import { useFormState, useFormStatus } from 'react-dom';
import { createPost } from '../actions';

function SubmitButton() {
  const { pending } = useFormStatus();
  
  return (
    &lt;button type="submit" disabled={pending}&gt;
      {pending ? 'Creating...' : 'Create Post'}
    &lt;/button&gt;
  );
}

export default function PostForm() {
  const [state, formAction] = useFormState(createPost, null);

  return (
    &lt;form action={formAction}&gt;
      {state?.error && &lt;p className="error"&gt;{state.error}&lt;/p&gt;}
      
      &lt;input name="title" placeholder="Title" required /&gt;
      &lt;textarea name="content" placeholder="Content" required /&gt;
      
      &lt;SubmitButton /&gt;
    &lt;/form&gt;
  );
}
</pre
        >
      </div>

      <div class="page">
        <h2 id="next-caching">5. Caching & Revalidation</h2>
        <p>Next.js has four caching mechanisms to optimize performance.</p>

        <h3>5.1 Caching Mechanisms</h3>
        <div class="example">
          <ol>
            <li>
              <strong>Request Memoization:</strong> Dedupe identical requests in
              a single render pass
            </li>
            <li>
              <strong>Data Cache:</strong> Persistent HTTP cache on the server
            </li>
            <li>
              <strong>Full Route Cache:</strong> Pre-rendered HTML and RSC
              payload
            </li>
            <li>
              <strong>Router Cache:</strong> Client-side cache of RSC payload
            </li>
          </ol>
        </div>

        <h3>5.2 Fetch Caching Options</h3>
        <pre>
// No caching - Always fetch fresh data
fetch('https://api.example.com/data', {
  cache: 'no-store'
});

// Cache with revalidation
fetch('https://api.example.com/data', {
  next: { revalidate: 60 } // Revalidate every 60 seconds
});

// Cache indefinitely (default for GET requests)
fetch('https://api.example.com/data', {
  cache: 'force-cache'
});

// Opt out of caching for entire route segment
// app/products/page.js
export const dynamic = 'force-dynamic';

// Or per route
export const revalidate = 60; // Revalidate every 60 seconds
export const dynamic = 'force-static'; // Always static

export default async function Page() {
  const data = await fetch('https://api.example.com/data');
  return &lt;div&gt;{/* ... */}&lt;/div&gt;;
}
</pre
        >

        <h3>5.3 On-Demand Revalidation</h3>
        <pre>
// Revalidate by path
import { revalidatePath } from 'next/cache';

export async function updatePost(postId, data) {
  'use server';
  
  await db.posts.update({
    where: { id: postId },
    data
  });
  
  // Revalidate specific path
  revalidatePath('/posts');
  revalidatePath(`/posts/${postId}`);
  
  // Revalidate all posts routes
  revalidatePath('/posts', 'layout'); // Revalidate entire layout
}

// Revalidate by tag
import { revalidateTag } from 'next/cache';

// When fetching, add tags
fetch('https://api.example.com/posts', {
  next: { tags: ['posts'] }
});

// Revalidate all fetches with this tag
export async function createPost(data) {
  'use server';
  
  await db.posts.create({ data });
  
  revalidateTag('posts');
}

// Multiple tags
fetch('https://api.example.com/posts/1', {
  next: { 
    tags: ['posts', 'post-1'],
    revalidate: 3600 
  }
});

// Revalidate multiple tags
revalidateTag('posts');
revalidateTag('post-1');
</pre
        >

        <h3>5.4 Incremental Static Regeneration (ISR)</h3>
        <pre>
// app/posts/[slug]/page.js

// Generate static pages for these slugs at build time
export async function generateStaticParams() {
  const posts = await fetch('https://api.example.com/posts').then(r =&gt; r.json());
  
  return posts.map(post =&gt; ({
    slug: post.slug,
  }));
}

// Revalidate every hour
export const revalidate = 3600;

export default async function PostPage({ params }) {
  const post = await fetch(
    `https://api.example.com/posts/${params.slug}`,
    { next: { revalidate: 3600 } }
  ).then(r =&gt; r.json());

  return (
    &lt;article&gt;
      &lt;h1&gt;{post.title}&lt;/h1&gt;
      &lt;div&gt;{post.content}&lt;/div&gt;
    &lt;/article&gt;
  );
}

// With dynamic parameter handling
export const dynamicParams = true; // or false

// false: Return 404 for slugs not in generateStaticParams
// true (default): Generate on-demand for new slugs
</pre
        >

        <h3>5.5 Route Segment Config</h3>
        <pre>
// app/dashboard/page.js

// Force dynamic rendering (no caching)
export const dynamic = 'force-dynamic';

// Force static rendering
export const dynamic = 'force-static';

// Automatic (default): Cache when possible
export const dynamic = 'auto';

// Error on dynamic usage
export const dynamic = 'error';

// Revalidation time
export const revalidate = 60; // seconds

// Disable revalidation
export const revalidate = false;

// Control fetch cache
export const fetchCache = 'auto'; // default
export const fetchCache = 'force-cache';
export const fetchCache = 'only-cache';
export const fetchCache = 'force-no-store';
export const fetchCache = 'default-no-store';
export const fetchCache = 'only-no-store';

// Specify runtime
export const runtime = 'nodejs'; // default
export const runtime = 'edge'; // Edge Runtime

// Control preferred region
export const preferredRegion = 'auto'; // default
export const preferredRegion = 'home';
export const preferredRegion = ['iad1', 'sfo1']; // specific regions
</pre
        >
      </div>

      <div class="page">
        <h2>6. Advanced Features</h2>

        <h3>6.1 Metadata API</h3>
        <pre>
// Static metadata
// app/page.js
export const metadata = {
  title: 'Home',
  description: 'Welcome to our website',
  keywords: ['nextjs', 'react', 'app router'],
  openGraph: {
    title: 'Home',
    description: 'Welcome to our website',
    images: ['/og-image.jpg'],
  },
  twitter: {
    card: 'summary_large_image',
    title: 'Home',
    description: 'Welcome to our website',
    images: ['/twitter-image.jpg'],
  },
};

// Dynamic metadata
// app/posts/[slug]/page.js
export async function generateMetadata({ params }) {
  const post = await fetch(
    `https://api.example.com/posts/${params.slug}`
  ).then(r =&gt; r.json());

  return {
    title: post.title,
    description: post.excerpt,
    openGraph: {
      title: post.title,
      description: post.excerpt,
      images: [post.coverImage],
      type: 'article',
      publishedTime: post.publishedAt,
      authors: [post.author.name],
    },
  };
}

// Metadata inheritance and merging
// app/layout.js
export const metadata = {
  title: {
    template: '%s | My Site',
    default: 'My Site',
  },
  description: 'Default description',
};

// app/blog/page.js
export const metadata = {
  title: 'Blog', // Becomes "Blog | My Site"
  description: 'Read our blog posts',
};

// Generate metadata with async operations
export async function generateMetadata({ params, searchParams }) {
  const product = await getProduct(params.id);
  
  return {
    title: product.name,
    description: product.description,
    openGraph: {
      images: [product.image],
    },
  };
}
</pre
        >

        <h3>6.2 Parallel Routes</h3>
        <p>
          Parallel routes allow you to render multiple pages in the same layout
          simultaneously.
        </p>

        <pre>
// Folder structure:
// app/
// ‚îú‚îÄ‚îÄ layout.js
// ‚îú‚îÄ‚îÄ @team/
// ‚îÇ   ‚îî‚îÄ‚îÄ page.js
// ‚îú‚îÄ‚îÄ @analytics/
// ‚îÇ   ‚îî‚îÄ‚îÄ page.js
// ‚îî‚îÄ‚îÄ page.js

// app/layout.js
export default function Layout({ children, team, analytics }) {
  return (
    &lt;div&gt;
      &lt;div&gt;{children}&lt;/div&gt;
      &lt;div className="sidebar"&gt;
        &lt;div&gt;{team}&lt;/div&gt;
        &lt;div&gt;{analytics}&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// app/@team/page.js
export default function TeamPage() {
  return &lt;div&gt;Team Dashboard&lt;/div&gt;;
}

// app/@analytics/page.js
export default function AnalyticsPage() {
  return &lt;div&gt;Analytics Dashboard&lt;/div&gt;;
}

// Conditional rendering with parallel routes
export default function Layout({ children, team, analytics, isAdmin }) {
  return (
    &lt;div&gt;
      {children}
      {isAdmin ? (
        &lt;div&gt;
          {team}
          {analytics}
        &lt;/div&gt;
      ) : null}
    &lt;/div&gt;
  );
}
</pre
        >

        <h3>6.3 Intercepting Routes</h3>
        <p>
          Intercepting routes allow you to load a route within the current
          layout while keeping the URL.
        </p>

        <pre>
// Folder structure:
// app/
// ‚îú‚îÄ‚îÄ feed/
// ‚îÇ   ‚îî‚îÄ‚îÄ page.js
// ‚îú‚îÄ‚îÄ photo/
// ‚îÇ   ‚îî‚îÄ‚îÄ [id]/
// ‚îÇ       ‚îî‚îÄ‚îÄ page.js
// ‚îî‚îÄ‚îÄ @modal/
//     ‚îî‚îÄ‚îÄ (.)photo/
//         ‚îî‚îÄ‚îÄ [id]/
//             ‚îî‚îÄ‚îÄ page.js

// Convention:
// (.) - same level
// (..) - one level up
// (..)(..) - two levels up
// (...) - from root app directory

// app/feed/page.js
export default function FeedPage() {
  return (
    &lt;div&gt;
      &lt;Link href="/photo/1"&gt;
        &lt;img src="/photo-1.jpg" alt="Photo 1" /&gt;
      &lt;/Link&gt;
    &lt;/div&gt;
  );
}

// app/@modal/(.)photo/[id]/page.js
export default function PhotoModal({ params }) {
  return (
    &lt;div className="modal"&gt;
      &lt;img src={`/photo-${params.id}.jpg`} /&gt;
    &lt;/div&gt;
  );
}

// app/photo/[id]/page.js
export default function PhotoPage({ params }) {
  return (
    &lt;div&gt;
      &lt;img src={`/photo-${params.id}.jpg`} /&gt;
    &lt;/div&gt;
  );
}

// When clicking link from feed: Opens modal
// When refreshing /photo/1: Shows full page
</pre
        >

        <h3>6.4 Route Groups</h3>
        <p>Route groups organize routes without affecting the URL structure.</p>

        <pre>
// Folder structure with route groups:
// app/
// ‚îú‚îÄ‚îÄ (marketing)/
// ‚îÇ   ‚îú‚îÄ‚îÄ layout.js          // Marketing layout
// ‚îÇ   ‚îú‚îÄ‚îÄ about/
// ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.js        // /about
// ‚îÇ   ‚îî‚îÄ‚îÄ blog/
// ‚îÇ       ‚îî‚îÄ‚îÄ page.js        // /blog
// ‚îî‚îÄ‚îÄ (shop)/
//     ‚îú‚îÄ‚îÄ layout.js          // Shop layout
//     ‚îú‚îÄ‚îÄ products/
//     ‚îÇ   ‚îî‚îÄ‚îÄ page.js        // /products
//     ‚îî‚îÄ‚îÄ cart/
//         ‚îî‚îÄ‚îÄ page.js        // /cart

// app/(marketing)/layout.js
export default function MarketingLayout({ children }) {
  return (
    &lt;div&gt;
      &lt;nav&gt;Marketing Nav&lt;/nav&gt;
      {children}
    &lt;/div&gt;
  );
}

// app/(shop)/layout.js
export default function ShopLayout({ children }) {
  return (
    &lt;div&gt;
      &lt;nav&gt;Shop Nav&lt;/nav&gt;
      {children}
    &lt;/div&gt;
  );
}

// Multiple root layouts using route groups
// app/(main)/layout.js
export default function MainLayout({ children }) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;
        &lt;header&gt;Main Header&lt;/header&gt;
        {children}
      &lt;/body&gt;
    &lt;/html&gt;
  );
}

// app/(admin)/layout.js
export default function AdminLayout({ children }) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;
        &lt;header&gt;Admin Header&lt;/header&gt;
        {children}
      &lt;/body&gt;
    &lt;/html&gt;
  );
}
</pre
        >
      </div>

      <div class="page">
        <h3>6.5 Middleware</h3>
        <pre>
// middleware.js (root of project)
import { NextResponse } from 'next/server';

export function middleware(request) {
  // Check authentication
  const token = request.cookies.get('token');
  
  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
  
  // Add custom headers
  const response = NextResponse.next();
  response.headers.set('x-custom-header', 'value');
  
  return response;
}

// Configure which routes use middleware
export const config = {
  matcher: [
    '/dashboard/:path*',
    '/api/:path*',
  ],
};

// Advanced middleware example
export function middleware(request) {
  const { pathname } = request.nextUrl;
  
  // Logging
  console.log(`Request to: ${pathname}`);
  
  // Geolocation redirect
  const country = request.geo?.country || 'US';
  if (country === 'GB' && !pathname.startsWith('/uk')) {
    return NextResponse.redirect(new URL('/uk' + pathname, request.url));
  }
  
  // A/B Testing
  const bucket = request.cookies.get('bucket');
  if (!bucket) {
    const response = NextResponse.next();
    response.cookies.set('bucket', Math.random() > 0.5 ? 'a' : 'b');
    return response;
  }
  
  // Rate limiting
  const ip = request.ip || 'unknown';
  const rateLimit = checkRateLimit(ip);
  if (!rateLimit.allowed) {
    return new NextResponse('Too Many Requests', { status: 429 });
  }
  
  return NextResponse.next();
}

// Rewrite URLs
export function middleware(request) {
  // Rewrite /blog/:slug to /posts/:slug
  if (request.nextUrl.pathname.startsWith('/blog/')) {
    const slug = request.nextUrl.pathname.replace('/blog/', '');
    return NextResponse.rewrite(new URL(`/posts/${slug}`, request.url));
  }
  
  return NextResponse.next();
}
</pre
        >

        <h3>6.6 Image Optimization</h3>
        <pre>
// next/image component
import Image from 'next/image';

export default function Page() {
  return (
    &lt;div&gt;
      {/* Local image */}
      &lt;Image
        src="/profile.jpg"
        alt="Profile"
        width={500}
        height={500}
        quality={90}
        priority // Load immediately
      /&gt;

      {/* Remote image */}
      &lt;Image
        src="https://example.com/image.jpg"
        alt="Remote image"
        width={800}
        height={600}
        placeholder="blur"
        blurDataURL="data:image/jpeg;base64,..."
      /&gt;

      {/* Fill parent container */}
      &lt;div style={{ position: 'relative', width: '100%', height: '400px' }}&gt;
        &lt;Image
          src="/hero.jpg"
          alt="Hero"
          fill
          style={{ objectFit: 'cover' }}
          sizes="100vw"
        /&gt;
      &lt;/div&gt;

      {/* Responsive images */}
      &lt;Image
        src="/responsive.jpg"
        alt="Responsive"
        width={1200}
        height={600}
        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      /&gt;
    &lt;/div&gt;
  );
}

// Configure allowed remote image domains
// next.config.js
module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'example.com',
        port: '',
        pathname: '/images/**',
      },
    ],
    formats: ['image/avif', 'image/webp'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
};
</pre
        >

        <h2 id="next-interview">7. Next.js Interview Questions</h2>

        <div class="question">
          <h4>
            Q1: Explain the difference between Server Components and Client
            Components in Next.js App Router.
          </h4>
        </div>
        <div class="answer">
          <p><strong>Server Components (Default):</strong></p>
          <ul>
            <li>Run only on the server</li>
            <li>
              Can directly access backend resources (databases, file system)
            </li>
            <li>Can use async/await for data fetching</li>
            <li>Don't increase client-side JavaScript bundle</li>
            <li>Cannot use hooks (useState, useEffect) or browser APIs</li>
            <li>Cannot handle interactivity</li>
          </ul>

          <p><strong>Client Components ('use client'):</strong></p>
          <ul>
            <li>Run on both server (initial render) and client</li>
            <li>Can use React hooks and browser APIs</li>
            <li>Handle interactivity and event listeners</li>
            <li>Add to JavaScript bundle size</li>
            <li>Can use Context API</li>
          </ul>

          <p>
            <strong>Best Practice:</strong> Use Server Components by default,
            only add 'use client' when you need interactivity, hooks, or browser
            APIs. Push Client Components to the leaves of your component tree.
          </p>
        </div>

        <div class="question">
          <h4>Q2: How does caching work in Next.js App Router?</h4>
        </div>
        <div class="answer">
          <p><strong>Four caching layers:</strong></p>

          <p>
            <strong>1. Request Memoization:</strong> Deduplicates identical
            fetch requests during a single render pass.
          </p>
          <pre>
// Both fetch the same data, but only one request is made
const data1 = await fetch('https://api.example.com/data');
const data2 = await fetch('https://api.example.com/data');
</pre
          >

          <p>
            <strong>2. Data Cache:</strong> Persistent HTTP cache on the server
            across requests and deployments.
          </p>
          <pre>
// Cached indefinitely
fetch('url', { cache: 'force-cache' });

// Revalidate every 60 seconds
fetch('url', { next: { revalidate: 60 } });

// Never cache
fetch('url', { cache: 'no-store' });
</pre
          >

          <p>
            <strong>3. Full Route Cache:</strong> Pre-rendered HTML and React
            Server Component payload stored on the server.
          </p>

          <p>
            <strong>4. Router Cache:</strong> Client-side cache of RSC payload
            stored in browser memory during user session.
          </p>

          <p>
            <strong>Revalidation:</strong> Can be time-based or on-demand using
            revalidatePath() or revalidateTag().
          </p>
        </div>
      </div>

      <div class="page">
        <div class="question">
          <h4>Q3: What are Server Actions and how do they work?</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> Server Actions are asynchronous functions
            that run on the server and can be called from Client or Server
            Components.
          </p>

          <pre>
// Define Server Action
'use server';

export async function createUser(formData) {
  const name = formData.get('name');
  const email = formData.get('email');
  
  // Direct database access
  const user = await db.users.create({
    data: { name, email }
  });
  
  revalidatePath('/users');
  return { success: true, user };
}

// Use in Server Component
&lt;form action={createUser}&gt;
  &lt;input name="name" /&gt;
  &lt;input name="email" /&gt;
  &lt;button type="submit"&gt;Create&lt;/button&gt;
&lt;/form&gt;

// Use in Client Component
'use client';
import { createUser } from './actions';

function Form() {
  const [state, formAction] = useFormState(createUser, null);
  
  return &lt;form action={formAction}&gt;...&lt;/form&gt;;
}
</pre
          >

          <p><strong>Benefits:</strong></p>
          <ul>
            <li>No need to create API routes</li>
            <li>Progressive enhancement (works without JavaScript)</li>
            <li>Automatic serialization of data</li>
            <li>Type-safe with TypeScript</li>
            <li>Can revalidate cache and redirect</li>
          </ul>
        </div>

        <div class="question">
          <h4>Q4: Explain the routing conventions in App Router.</h4>
        </div>
        <div class="answer">
          <p><strong>Special Files:</strong></p>
          <ul>
            <li>
              <strong>page.js:</strong> Defines UI for a route, makes it
              publicly accessible
            </li>
            <li>
              <strong>layout.js:</strong> Shared UI that wraps children,
              preserves state
            </li>
            <li>
              <strong>template.js:</strong> Similar to layout but re-renders on
              navigation
            </li>
            <li>
              <strong>loading.js:</strong> Loading UI with automatic Suspense
              boundary
            </li>
            <li>
              <strong>error.js:</strong> Error UI with automatic Error boundary
              (must be Client Component)
            </li>
            <li><strong>not-found.js:</strong> UI for 404 errors</li>
            <li><strong>route.js:</strong> API endpoint (Route Handler)</li>
          </ul>

          <p><strong>Dynamic Routes:</strong></p>
          <pre>
[slug]/page.js          // /blog/hello-world
[...slug]/page.js       // /shop/a/b/c (catch-all)
[[...slug]]/page.js     // /docs or /docs/a/b (optional catch-all)
</pre
          >

          <p>
            <strong>Route Groups:</strong> Organize routes without affecting URL
            using (folder)
          </p>
          <p>
            <strong>Parallel Routes:</strong> Render multiple pages
            simultaneously using @folder
          </p>
          <p>
            <strong>Intercepting Routes:</strong> Show route within current
            layout using (.)
          </p>
        </div>

        <div class="question">
          <h4>Q5: How does streaming work in Next.js App Router?</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> Streaming allows you to progressively
            render UI from the server. Instead of waiting for all data to load
            before showing anything, you can stream content as it becomes
            available.
          </p>

          <pre>
// Automatic with loading.js
// app/dashboard/loading.js
export default function Loading() {
  return &lt;Skeleton /&gt;;
}

// Manual with Suspense
import { Suspense } from 'react';

export default function Page() {
  return (
    &lt;div&gt;
      &lt;Header /&gt;
      
      &lt;Suspense fallback={&lt;LoadingSkeleton /&gt;}&gt;
        &lt;SlowComponent /&gt;
      &lt;/Suspense&gt;
      
      &lt;Suspense fallback={&lt;LoadingSkeleton /&gt;}&gt;
        &lt;AnotherSlowComponent /&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  );
}
</pre
          >

          <p><strong>Benefits:</strong></p>
          <ul>
            <li>Improved Time to First Byte (TTFB)</li>
            <li>Better perceived performance</li>
            <li>Independent loading of components</li>
            <li>Prioritize important content</li>
          </ul>

          <p>
            <strong>How it works:</strong> Server sends HTML in chunks. Browser
            can render and show content incrementally without waiting for entire
            response.
          </p>
        </div>

        <div class="question">
          <h4>
            Q6: What is the difference between dynamic and static rendering?
          </h4>
        </div>
        <div class="answer">
          <p><strong>Static Rendering (Default):</strong></p>
          <ul>
            <li>Routes are rendered at build time or after revalidation</li>
            <li>Result is cached and can be served from CDN</li>
            <li>Best for content that doesn't change often</li>
          </ul>

          <pre>
// Static by default
export default async function Page() {
  const data = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 } // ISR: Revalidate every hour
  });
  return &lt;div&gt;{/* ... */}&lt;/div&gt;;
}
</pre
          >

          <p><strong>Dynamic Rendering:</strong></p>
          <ul>
            <li>Routes are rendered at request time</li>
            <li>
              Can access request-specific information (cookies, headers, search
              params)
            </li>
            <li>Best for personalized or real-time content</li>
          </ul>

          <pre>
// Force dynamic
export const dynamic = 'force-dynamic';

// Or use dynamic functions
import { cookies } from 'next/headers';

export default async function Page() {
  const cookieStore = cookies();
  const theme = cookieStore.get('theme');
  // Now route is dynamic
}
</pre
          >

          <p>
            <strong>Next.js automatically chooses:</strong> Uses static by
            default, switches to dynamic if you use dynamic functions (cookies,
            headers, searchParams) or no-store cache.
          </p>
        </div>
      </div>

      <div class="page">
        <div class="question">
          <h4>Q7: Explain the Metadata API in Next.js.</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> The Metadata API allows you to define
            metadata for SEO and social sharing in a type-safe way.
          </p>

          <pre>
// Static metadata
export const metadata = {
  title: 'My Page',
  description: 'Page description',
  keywords: ['next.js', 'react'],
  openGraph: {
    title: 'My Page',
    description: 'Page description',
    images: ['/og-image.jpg'],
  },
};

// Dynamic metadata
export async function generateMetadata({ params }) {
  const product = await getProduct(params.id);
  
  return {
    title: product.name,
    description: product.description,
    openGraph: {
      images: [product.image],
    },
  };
}

// Template pattern (in layout)
export const metadata = {
  title: {
    template: '%s | My Site',
    default: 'My Site',
  },
};

// Child pages will use template
export const metadata = {
  title: 'About', // Becomes "About | My Site"
};
</pre
          >

          <p><strong>Benefits:</strong></p>
          <ul>
            <li>Type-safe metadata configuration</li>
            <li>Automatic optimization (deduplication)</li>
            <li>Supports all meta tags (Open Graph, Twitter, etc.)</li>
            <li>File-based metadata (favicon, robots.txt, sitemap.xml)</li>
          </ul>
        </div>

        <div class="question">
          <h4>Q8: How do you handle authentication in App Router?</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> Authentication can be handled at multiple
            levels:
          </p>

          <p>
            <strong>1. Middleware (Recommended for route protection):</strong>
          </p>
          <pre>
// middleware.js
import { NextResponse } from 'next/server';

export function middleware(request) {
  const token = request.cookies.get('token');
  
  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
  
  return NextResponse.next();
}

export const config = {
  matcher: '/dashboard/:path*',
};
</pre
          >

          <p><strong>2. Server Components (Data access control):</strong></p>
          <pre>
// app/dashboard/page.js
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';

async function getUser() {
  const cookieStore = cookies();
  const token = cookieStore.get('token');
  
  if (!token) return null;
  
  const res = await fetch('https://api.example.com/user', {
    headers: { Authorization: `Bearer ${token}` }
  });
  
  return res.json();
}

export default async function Dashboard() {
  const user = await getUser();
  
  if (!user) {
    redirect('/login');
  }
  
  return &lt;div&gt;Welcome {user.name}&lt;/div&gt;;
}
</pre
          >

          <p><strong>3. Route Handlers (API protection):</strong></p>
          <pre>
// app/api/user/route.js
import { cookies } from 'next/headers';

export async function GET() {
  const cookieStore = cookies();
  const token = cookieStore.get('token');
  
  if (!token) {
    return new Response('Unauthorized', { status: 401 });
  }
  
  // Verify token and get user
  const user = await verifyToken(token);
  return Response.json({ user });
}
</pre
          >

          <p><strong>Best practices:</strong></p>
          <ul>
            <li>Use httpOnly cookies for tokens</li>
            <li>Implement CSRF protection</li>
            <li>Use middleware for route-level protection</li>
            <li>Validate auth in Server Components for data access</li>
            <li>Consider using NextAuth.js for full auth solution</li>
          </ul>
        </div>

        <div class="question">
          <h4>
            Q9: What are the benefits of Server Components over traditional SSR?
          </h4>
        </div>
        <div class="answer">
          <p><strong>Traditional SSR (Pages Router):</strong></p>
          <ul>
            <li>Entire page is a single unit</li>
            <li>All data fetching happens in getServerSideProps</li>
            <li>All components become client-side after hydration</li>
            <li>Large JavaScript bundles</li>
          </ul>

          <p><strong>Server Components (App Router):</strong></p>
          <ul>
            <li>
              <strong>Zero bundle size:</strong> Server Components don't add to
              client JS bundle
            </li>
            <li>
              <strong>Direct backend access:</strong> Can access databases, file
              system directly
            </li>
            <li>
              <strong>Automatic code splitting:</strong> Each Server Component
              is a natural split point
            </li>
            <li><strong>Streaming:</strong> Can send UI progressively</li>
            <li>
              <strong>No hydration cost:</strong> Server Components never
              hydrate
            </li>
            <li><strong>Colocation:</strong> Fetch data where you need it</li>
          </ul>

          <pre>
// Traditional SSR
export async function getServerSideProps() {
  const data = await fetchData();
  return { props: { data } };
}

export default function Page({ data }) {
  // Entire component becomes client-side after hydration
  return &lt;div&gt;{data}&lt;/div&gt;;
}

// Server Components
export default async function Page() {
  // This entire component stays on server
  const data = await fetchData();
  return &lt;div&gt;{data}&lt;/div&gt;;
}
</pre
          >

          <p>
            <strong>Result:</strong> Faster page loads, smaller bundles, better
            performance, especially on low-powered devices.
          </p>
        </div>
      </div>

      <div class="page">
        <div class="question">
          <h4>Q10: How do you optimize performance in Next.js App Router?</h4>
        </div>
        <div class="answer">
          <p><strong>1. Use Server Components by default:</strong></p>
          <pre>
// Keep Client Components at the leaves
export default function Page() {
  return (
    &lt;div&gt;
      {/* Server Component - no JS sent */}
      &lt;Header /&gt;
      
      {/* Only this is a Client Component */}
      &lt;InteractiveWidget /&gt;
      
      {/* Server Component */}
      &lt;Footer /&gt;
    &lt;/div&gt;
  );
}
</pre
          >

          <p><strong>2. Implement proper caching:</strong></p>
          <pre>
// Cache with revalidation
fetch('url', { next: { revalidate: 3600 } });

// Tag-based revalidation
fetch('url', { next: { tags: ['products'] } });

// Then revalidate when needed
revalidateTag('products');
</pre
          >

          <p><strong>3. Use Streaming and Suspense:</strong></p>
          <pre>
&lt;Suspense fallback={&lt;Skeleton /&gt;}&gt;
  &lt;SlowComponent /&gt;
&lt;/Suspense&gt;
</pre
          >

          <p><strong>4. Optimize images:</strong></p>
          <pre>
&lt;Image
  src="/hero.jpg"
  alt="Hero"
  width={1200}
  height={600}
  priority  // For above-the-fold images
  placeholder="blur"
/&gt;
</pre
          >

          <p><strong>5. Parallel data fetching:</strong></p>
          <pre>
// Fetch in parallel
const [user, posts] = await Promise.all([
  getUser(),
  getPosts(),
]);
</pre
          >

          <p><strong>6. Use loading.js for instant loading states</strong></p>
          <p>
            <strong>7. Implement Incremental Static Regeneration (ISR)</strong>
          </p>
          <p>
            <strong
              >8. Use Route Handlers for API routes instead of external
              APIs</strong
            >
          </p>
          <p><strong>9. Enable compression in production</strong></p>
          <p><strong>10. Monitor with Next.js Speed Insights</strong></p>
        </div>

        <div class="question">
          <h4>Q11: Explain Partial Prerendering in Next.js.</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> Partial Prerendering (PPR) is an
            experimental feature that combines static and dynamic rendering in a
            single route.
          </p>

          <p><strong>How it works:</strong></p>
          <ul>
            <li>Static shell is prerendered at build time</li>
            <li>Dynamic content is streamed in at runtime</li>
            <li>Uses Suspense boundaries to define dynamic sections</li>
            <li>Best of both worlds: fast initial load + dynamic content</li>
          </ul>

          <pre>
// next.config.js
const nextConfig = {
  experimental: {
    ppr: true,
  },
};

// app/page.js
import { Suspense } from 'react';

export default function Page() {
  return (
    &lt;div&gt;
      {/* Static - prerendered */}
      &lt;Header /&gt;
      &lt;Hero /&gt;
      
      {/* Dynamic - streamed at runtime */}
      &lt;Suspense fallback={&lt;Skeleton /&gt;}&gt;
        &lt;UserDashboard /&gt;
      &lt;/Suspense&gt;
      
      {/* Static - prerendered */}
      &lt;Footer /&gt;
    &lt;/div&gt;
  );
}
</pre
          >

          <p><strong>Benefits:</strong></p>
          <ul>
            <li>Fast initial page load (static shell)</li>
            <li>Can include personalized content</li>
            <li>Better Core Web Vitals</li>
            <li>Automatic optimization</li>
          </ul>
        </div>

        <div class="question">
          <h4>Q12: How do you handle environment variables in App Router?</h4>
        </div>
        <div class="answer">
          <p><strong>Server-side (default):</strong></p>
          <pre>
// .env.local
DATABASE_URL=postgres://...
API_KEY=secret123

// In Server Components or Route Handlers
const db = await connect(process.env.DATABASE_URL);
const data = await fetch('api', {
  headers: { 'X-API-Key': process.env.API_KEY }
});
</pre
          >

          <p><strong>Client-side (must prefix with NEXT_PUBLIC_):</strong></p>
          <pre>
// .env.local
NEXT_PUBLIC_API_URL=https://api.example.com
NEXT_PUBLIC_GA_ID=G-XXXXXXXXXX

// In Client Components
'use client';

const apiUrl = process.env.NEXT_PUBLIC_API_URL;
</pre
          >

          <p><strong>Environment-specific files:</strong></p>
          <ul>
            <li>.env - All environments</li>
            <li>.env.local - Local overrides (gitignored)</li>
            <li>.env.development - Development only</li>
            <li>.env.production - Production only</li>
          </ul>

          <p><strong>Best practices:</strong></p>
          <ul>
            <li>Never commit .env.local</li>
            <li>Use NEXT_PUBLIC_ only for truly public values</li>
            <li>Keep secrets server-side</li>
            <li>Use different values per environment</li>
          </ul>
        </div>

        <div class="question">
          <h4>
            Q13: What is the difference between layout.js and template.js?
          </h4>
        </div>
        <div class="answer">
          <p><strong>layout.js:</strong></p>
          <ul>
            <li>Preserves state across route changes</li>
            <li>Does not re-render on navigation</li>
            <li>Can be nested</li>
            <li>Use for persistent UI (nav, sidebar)</li>
          </ul>

          <pre>
// app/layout.js
export default function Layout({ children }) {
  // State is preserved during navigation
  return (
    &lt;div&gt;
      &lt;Nav /&gt;
      {children}
    &lt;/div&gt;
  );
}
</pre
          >

          <p><strong>template.js:</strong></p>
          <ul>
            <li>Creates new instance on each navigation</li>
            <li>Does re-render and remount</li>
            <li>State is NOT preserved</li>
            <li>Use when you need fresh state or effects to run</li>
          </ul>

          <pre>
// app/template.js
export default function Template({ children }) {
  // Re-runs on every navigation
  useEffect(() => {
    // Analytics, animations, etc.
  }, []);

  return &lt;div&gt;{children}&lt;/div&gt;;
}
</pre
          >

          <p><strong>When to use template.js:</strong></p>
          <ul>
            <li>CSS/JS animations on route change</li>
            <li>Analytics tracking per page view</li>
            <li>Features that rely on useEffect</li>
            <li>Reset state between routes</li>
          </ul>
        </div>

        <div class="question">
          <h4>Q14: How do you handle forms in Next.js App Router?</h4>
        </div>
        <div class="answer">
          <p>
            <strong>1. With Server Actions (Progressive Enhancement):</strong>
          </p>
          <pre>
// app/actions.js
'use server';

export async function createPost(formData) {
  const title = formData.get('title');
  const content = formData.get('content');
  
  // Validation
  if (!title || !content) {
    return { error: 'All fields required' };
  }
  
  // Save to database
  await db.posts.create({ data: { title, content } });
  
  revalidatePath('/posts');
  redirect('/posts');
}

// app/posts/new/page.js
import { createPost } from '../actions';

export default function NewPost() {
  return (
    &lt;form action={createPost}&gt;
      &lt;input name="title" required /&gt;
      &lt;textarea name="content" required /&gt;
      &lt;button type="submit"&gt;Create&lt;/button&gt;
    &lt;/form&gt;
  );
}
</pre
          >

          <p><strong>2. With Client-side validation:</strong></p>
          <pre>
'use client';

import { useFormState, useFormStatus } from 'react-dom';
import { createPost } from './actions';

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    &lt;button type="submit" disabled={pending}&gt;
      {pending ? 'Submitting...' : 'Submit'}
    &lt;/button&gt;
  );
}

export default function Form() {
  const [state, formAction] = useFormState(createPost, null);

  return (
    &lt;form action={formAction}&gt;
      {state?.error && &lt;p className="error"&gt;{state.error}&lt;/p&gt;}
      
      &lt;input name="title" required /&gt;
      &lt;textarea name="content" required /&gt;
      
      &lt;SubmitButton /&gt;
    &lt;/form&gt;
  );
}
</pre
          >

          <p><strong>3. With Route Handlers (API approach):</strong></p>
          <pre>
// app/api/posts/route.js
export async function POST(request) {
  const body = await request.json();
  
  // Validation
  if (!body.title || !body.content) {
    return Response.json(
      { error: 'All fields required' },
      { status: 400 }
    );
  }
  
  const post = await db.posts.create({ data: body });
  return Response.json({ post }, { status: 201 });
}

// Client Component
'use client';

export default function Form() {
  const [loading, setLoading] = useState(false);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    
    const formData = new FormData(e.target);
    const data = Object.fromEntries(formData);
    
    const res = await fetch('/api/posts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    
    setLoading(false);
    
    if (res.ok) {
      router.push('/posts');
    }
  };
  
  return &lt;form onSubmit={handleSubmit}&gt;...&lt;/form&gt;;
}
</pre
          >
        </div>
      </div>

      <div class="page">
        <div class="question">
          <h4>Q15: Explain the concept of React Server Components payload.</h4>
        </div>
        <div class="answer">
          <p>
            <strong>Answer:</strong> The RSC payload is a special data format
            that Next.js uses to represent the rendered Server Components.
          </p>

          <p><strong>What it contains:</strong></p>
          <ul>
            <li>Rendered output of Server Components</li>
            <li>Placeholders for Client Components</li>
            <li>References to Client Component JavaScript chunks</li>
            <li>Props passed to Client Components</li>
          </ul>

          <p><strong>How it works:</strong></p>
          <ol>
            <li>Server renders Server Components to RSC payload</li>
            <li>Payload is streamed to the client</li>
            <li>Client reconstructs React tree using payload</li>
            <li>Client Components are hydrated with their JavaScript</li>
            <li>Server Component output is inserted as plain HTML</li>
          </ol>

          <p><strong>Benefits:</strong></p>
          <ul>
            <li>Efficient wire format (smaller than HTML)</li>
            <li>Can be cached and reused</li>
            <li>Enables partial hydration</li>
            <li>Allows mixing server and client components</li>
          </ul>

          <pre>
// Example RSC Payload structure (simplified)
[
  ["$", "div", null, {
    children: [
      ["$", "h1", null, { children: "Hello" }],
      ["$", "$L1", null, { /* Client Component reference */ }],
      ["$", "p", null, { children: "Server rendered text" }]
    ]
  }]
]
</pre
          >
        </div>

        <h2>8. Comparison: React vs Next.js</h2>

        <div class="example">
          <table style="width: 100%; border-collapse: collapse">
            <tr>
              <th
                style="
                  border: 1px solid #ddd;
                  padding: 8px;
                  background: #f2f2f2;
                "
              >
                Aspect
              </th>
              <th
                style="
                  border: 1px solid #ddd;
                  padding: 8px;
                  background: #f2f2f2;
                "
              >
                React
              </th>
              <th
                style="
                  border: 1px solid #ddd;
                  padding: 8px;
                  background: #f2f2f2;
                "
              >
                Next.js App Router
              </th>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">Type</td>
              <td style="border: 1px solid #ddd; padding: 8px">Library</td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Full-stack Framework
              </td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">Rendering</td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Client-side only
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Server + Client
              </td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">Routing</td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Needs React Router
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Built-in file-based
              </td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">
                Data Fetching
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">
                useEffect + fetch
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">
                async components
              </td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">SEO</td>
              <td style="border: 1px solid #ddd; padding: 8px">Poor (CSR)</td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Excellent (SSR/SSG)
              </td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">API Routes</td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Need separate backend
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Built-in Route Handlers
              </td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">
                Image Optimization
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">Manual</td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Automatic with Image component
              </td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px">
                Code Splitting
              </td>
              <td style="border: 1px solid #ddd; padding: 8px">React.lazy</td>
              <td style="border: 1px solid #ddd; padding: 8px">
                Automatic + React.lazy
              </td>
            </tr>
          </table>
        </div>

        <h2>9. Best Practices Summary</h2>

        <h3>React Best Practices:</h3>
        <ul>
          <li>Keep components small and focused</li>
          <li>Use functional components with hooks</li>
          <li>Avoid prop drilling - use Context or composition</li>
          <li>Memoize expensive computations with useMemo</li>
          <li>Use useCallback for functions passed to memoized children</li>
          <li>Implement error boundaries for graceful error handling</li>
          <li>Keep side effects in useEffect with proper dependencies</li>
          <li>Use key prop correctly in lists</li>
          <li>Avoid mutating state directly</li>
          <li>Profile before optimizing</li>
        </ul>

        <h3>Next.js App Router Best Practices:</h3>
        <ul>
          <li>Use Server Components by default</li>
          <li>Only use 'use client' when necessary</li>
          <li>Fetch data where you need it</li>
          <li>Implement proper caching strategies</li>
          <li>Use loading.js for instant loading states</li>
          <li>Implement error.js for error handling</li>
          <li>Use Suspense for streaming</li>
          <li>Optimize images with Next Image component</li>
          <li>Use Server Actions for mutations</li>
          <li>Implement proper metadata for SEO</li>
          <li>Use middleware for edge-side logic</li>
          <li>Keep Client Components at the leaves</li>
        </ul>

        <h2>10. Common Pitfalls to Avoid</h2>

        <h3>React Pitfalls:</h3>
        <ul>
          <li>Forgetting dependency arrays in useEffect</li>
          <li>Using index as key in dynamic lists</li>
          <li>Mutating state directly</li>
          <li>Creating components inside render functions</li>
          <li>Not cleaning up side effects</li>
          <li>Overusing Context</li>
          <li>Premature optimization with memo/useMemo</li>
        </ul>

        <h3>Next.js Pitfalls:</h3>
        <ul>
          <li>Using Client Components when Server would work</li>
          <li>Not understanding caching behavior</li>
          <li>Fetching data in Client Components unnecessarily</li>
          <li>Not implementing loading and error states</li>
          <li>Exposing secrets in Client Components</li>
          <li>Not using proper revalidation strategies</li>
          <li>Importing Server Components into Client Components</li>
        </ul>
      </div>

      <div class="page">
        <h2>Conclusion</h2>

        <p>
          React and Next.js App Router represent the cutting edge of modern web
          development. React provides the foundation with its component-based
          architecture, hooks, and declarative programming model. Next.js builds
          on this foundation with Server Components, file-based routing, and
          built-in optimizations.
        </p>

        <h3>When to Use React:</h3>
        <ul>
          <li>Building SPAs with complex client-side interactions</li>
          <li>When you need full control over routing and architecture</li>
          <li>When building component libraries</li>
          <li>For applications that don't need SEO</li>
        </ul>

        <h3>When to Use Next.js App Router:</h3>
        <ul>
          <li>Building full-stack applications</li>
          <li>When SEO is important</li>
          <li>Content-heavy sites (blogs, e-commerce)</li>
          <li>When you want automatic optimizations</li>
          <li>When you need server-side logic</li>
        </ul>

        <h3>Key Takeaways:</h3>

        <div class="key-point">
          <h4>React Core Concepts:</h4>
          <ul>
            <li>Components are the building blocks</li>
            <li>Props flow down, events flow up</li>
            <li>State triggers re-renders</li>
            <li>Hooks enable stateful functional components</li>
            <li>Virtual DOM optimizes updates</li>
          </ul>
        </div>

        <div class="key-point">
          <h4>Next.js App Router Fundamentals:</h4>
          <ul>
            <li>Server Components by default</li>
            <li>File-system based routing</li>
            <li>Built-in data fetching and caching</li>
            <li>Streaming and Suspense for progressive rendering</li>
            <li>Server Actions for mutations</li>
            <li>Automatic optimizations out of the box</li>
          </ul>
        </div>

        <h3>Learning Path:</h3>
        <ol>
          <li>
            <strong>Master React Fundamentals:</strong> Components, props,
            state, hooks
          </li>
          <li>
            <strong>Understand React Patterns:</strong> Custom hooks, HOCs,
            render props, compound components
          </li>
          <li>
            <strong>Learn Performance Optimization:</strong> Memoization, code
            splitting, virtualization
          </li>
          <li>
            <strong>Explore Next.js Basics:</strong> Routing, layouts, data
            fetching
          </li>
          <li>
            <strong>Deep Dive into Server Components:</strong> Understand the
            paradigm shift
          </li>
          <li>
            <strong>Master Caching:</strong> Learn all four caching layers
          </li>
          <li>
            <strong>Build Real Projects:</strong> Apply concepts in production
            apps
          </li>
        </ol>

        <h3>Additional Resources:</h3>
        <ul>
          <li>React Official Documentation: <code>react.dev</code></li>
          <li>Next.js Official Documentation: <code>nextjs.org/docs</code></li>
          <li>React Server Components RFC</li>
          <li>Next.js App Router Playground</li>
          <li>Vercel Edge Network Documentation</li>
        </ul>

        <div
          style="
            text-align: center;
            margin-top: 60px;
            padding: 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
          "
        >
          <h2 style="color: white; border: none; margin: 0">
            Happy Coding! üöÄ
          </h2>
          <p style="margin-top: 20px; font-size: 1.1em">
            Master these concepts and you'll be well-equipped to build modern,
            performant web applications.
          </p>
        </div>
      </div>

      <div class="page" style="background: #f8f9fa">
        <h2 style="text-align: center; color: #667eea">About This Guide</h2>
        <p style="text-align: center; margin-top: 20px">
          This comprehensive guide covers React.js and Next.js App Router
          concepts in depth, providing examples and interview questions to help
          you master modern web development.
        </p>

        <div
          style="
            margin-top: 40px;
            padding: 30px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
          "
        >
          <h3 style="color: #764ba2">Topics Covered:</h3>
          <ul style="line-height: 2">
            <li>React Fundamentals & Core Concepts</li>
            <li>React Hooks (useState, useEffect, useContext, etc.)</li>
            <li>Advanced React Patterns</li>
            <li>Performance Optimization Techniques</li>
            <li>Next.js App Router Architecture</li>
            <li>Server Components vs Client Components</li>
            <li>Data Fetching & Caching Strategies</li>
            <li>Routing, Layouts & Special Files</li>
            <li>30+ Interview Questions with Detailed Answers</li>
          </ul>
        </div>

        <div style="margin-top: 40px; text-align: center">
          <p style="font-size: 0.9em; color: #666">Created: November 2024</p>
          <p style="font-size: 0.9em; color: #666">For educational purposes</p>
        </div>
      </div>
    </div>

    <script>
      // Print functionality
      document
        .querySelector(".export-btn")
        .addEventListener("click", function () {
          window.print();
        });
    </script>
  </body>
</html>
